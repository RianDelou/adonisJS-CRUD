{"version":3,"sources":["../src/compiler/buffer.ts","../src/scripts/field/variables.ts","../src/compiler/nodes/base.ts","../src/scripts/array/guard.ts","../src/scripts/field/is_valid_guard.ts","../src/scripts/field/null_output.ts","../src/scripts/field/validations.ts","../src/scripts/array/initial_output.ts","../src/scripts/field/existence_validations.ts","../src/compiler/nodes/tuple.ts","../src/scripts/array/loop.ts","../src/compiler/nodes/array.ts","../src/scripts/union/parse.ts","../src/scripts/define_else_conditon.ts","../src/scripts/define_conditional_guard.ts","../src/compiler/nodes/union.ts","../src/scripts/record/loop.ts","../src/scripts/object/guard.ts","../src/scripts/object/initial_output.ts","../src/compiler/nodes/record.ts","../src/scripts/object/move_unknown_properties.ts","../src/compiler/nodes/object.ts","../src/compiler/fields/root_field.ts","../src/scripts/field/value_output.ts","../src/compiler/nodes/literal.ts","../src/compiler/fields/array_field.ts","../src/compiler/fields/tuple_field.ts","../src/scripts/report_errors.ts","../src/compiler/fields/object_field.ts","../src/compiler/fields/record_field.ts","../src/scripts/define_inline_functions.ts","../src/scripts/define_error_messages.ts","../src/compiler/main.ts","../src/refs_builder.ts"],"sourcesContent":["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Compiler buffer to collect JS fragments in memory\n */\nexport class CompilerBuffer {\n  #content: string = ''\n\n  /**\n   * The character used to create a new line\n   */\n  newLine = '\\n'\n\n  /**\n   * Write statement ot the output\n   */\n  writeStatement(statement: string) {\n    this.#content = `${this.#content}${this.newLine}${statement}`\n  }\n\n  /**\n   * Creates a child buffer\n   */\n  child() {\n    return new CompilerBuffer()\n  }\n\n  /**\n   * Returns the buffer contents as string\n   */\n  toString() {\n    return this.#content\n  }\n\n  /**\n   * Flush in-memory string\n   */\n  flush() {\n    this.#content = ''\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { RefIdentifier } from '../../types.js'\n\ntype FieldOptions = {\n  parentExpression: string\n  variableName: string\n  valueExpression: string\n  fieldNameExpression: string\n  wildCardPath: string\n  parentValueExpression: string\n  isArrayMember: boolean\n  parseFnRefId?: RefIdentifier\n}\n\n/**\n * Returns JS fragment for defining the field variables. It includes, the field\n * value variable, context variable, and a boolean to know if the field\n * exists.\n */\nexport function defineFieldVariables({\n  parseFnRefId,\n  variableName,\n  wildCardPath,\n  isArrayMember,\n  valueExpression,\n  parentExpression,\n  fieldNameExpression,\n  parentValueExpression,\n}: FieldOptions) {\n  const inValueExpression = parseFnRefId\n    ? `refs['${parseFnRefId}'](${valueExpression}, {\n      data: root,\n      meta: meta,\n      parent: ${parentValueExpression}\n    })`\n    : valueExpression\n\n  /**\n   * Field path output expression is the value that is\n   * returned when \"field.getFieldPath\" method is\n   * called.\n   */\n  let fieldPathOutputExpression = ''\n\n  /**\n   * When we are a direct member of a root field, we will not prefix the root path, since\n   * there is no path to prefix, its just root.\n   */\n  if (parentExpression === 'root' || parentExpression === 'root_item') {\n    fieldPathOutputExpression = fieldNameExpression\n  } else if (fieldNameExpression !== \"''\") {\n    /**\n     * When we are the root ourselves, we will return an empty string\n     * value.\n     */\n    fieldPathOutputExpression = `${parentExpression}.getFieldPath() + '.' + ${fieldNameExpression}`\n  }\n\n  return `const ${variableName} = defineValue(${inValueExpression}, {\n  data: root,\n  meta: meta,\n  name: ${fieldNameExpression},\n  wildCardPath: '${wildCardPath}',\n  getFieldPath() {\n    return ${fieldPathOutputExpression};\n  },\n  mutate: defineValue,\n  report: report,\n  isValid: true,\n  parent: ${parentValueExpression},\n  isArrayMember: ${isArrayMember},\n});`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineFieldVariables } from '../../scripts/field/variables.js'\nimport type { CompilerField, CompilerNodes, CompilerParent } from '../../types.js'\n\nexport abstract class BaseNode {\n  #node: CompilerNodes\n  #parentField?: CompilerField\n  protected field: CompilerField\n\n  constructor(\n    node: CompilerNodes,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    this.#parentField = parentField\n    this.#node = node\n\n    if (this.#parentField) {\n      this.field = this.#parentField\n    } else {\n      compiler.variablesCounter++\n      this.field = compiler.createFieldFor(node, parent)\n    }\n  }\n\n  protected defineField(buffer: CompilerBuffer) {\n    if (!this.#parentField) {\n      buffer.writeStatement(\n        defineFieldVariables({\n          fieldNameExpression: this.field.fieldNameExpression,\n          isArrayMember: this.field.isArrayMember,\n          parentExpression: this.field.parentExpression,\n          parentValueExpression: this.field.parentValueExpression,\n          valueExpression: this.field.valueExpression,\n          variableName: this.field.variableName,\n          wildCardPath: this.field.wildCardPath,\n          parseFnRefId: 'parseFnId' in this.#node ? this.#node.parseFnId : undefined,\n        })\n      )\n    }\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ArrayGuardOptions = {\n  variableName: string\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside an array conditional\n */\nexport function defineArrayGuard({ variableName, guardedCodeSnippet }: ArrayGuardOptions) {\n  return `if (ensureIsArray(${variableName})) {\n${guardedCodeSnippet}\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ObjectGuardOptions = {\n  variableName: string\n  bail: boolean\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside a valid guard\n */\nexport function defineIsValidGuard({ variableName, bail, guardedCodeSnippet }: ObjectGuardOptions) {\n  if (!bail) {\n    return guardedCodeSnippet\n  }\n\n  return `if (${variableName}.isValid) {\n${guardedCodeSnippet}\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { RefIdentifier } from '../../types.js'\n\n/**\n * Options accepts by the output script\n */\ntype OutputOptions = {\n  outputExpression: string\n  variableName: string\n  allowNull: boolean\n  transformFnRefId?: RefIdentifier\n  conditional?: 'if' | 'else if'\n}\n\n/**\n * Returns JS fragment for writing the null value to the output.\n */\nexport function defineFieldNullOutput({\n  allowNull,\n  conditional,\n  variableName,\n  outputExpression,\n  transformFnRefId,\n}: OutputOptions) {\n  if (!allowNull) {\n    return ''\n  }\n\n  return `${conditional || 'if'}(${variableName}.value === null) {\n  ${outputExpression} = ${\n    transformFnRefId ? `refs['${transformFnRefId}'](null, ${variableName});` : 'null;'\n  }\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ValidationNode } from '../../types.js'\n\n/**\n * Options accepts by the validation script\n */\ntype ValidationOptions = {\n  bail: boolean\n  variableName: string\n  validations: ValidationNode[]\n\n  /**\n   * Drop missing conditional check regardless of whether\n   * rule is implicit or not\n   */\n  dropMissingCheck: boolean\n}\n\n/**\n * Helper to generate a conditional based upon enabled conditions.\n */\nfunction wrapInConditional(conditions: [string, string], wrappingCode: string) {\n  const [first, second] = conditions\n  if (first && second) {\n    return `if (${first} && ${second}) {\n  ${wrappingCode}\n}`\n  }\n\n  if (first) {\n    return `if (${first}) {\n  ${wrappingCode}\n}`\n  }\n\n  if (second) {\n    return `if (${second}) {\n  ${wrappingCode}\n}`\n  }\n\n  return wrappingCode\n}\n\n/**\n * Emits code for executing a validation function\n */\nfunction emitValidationSnippet(\n  { isAsync, implicit, ruleFnId }: ValidationNode,\n  variableName: string,\n  bail: boolean,\n  dropMissingCheck: boolean\n) {\n  const rule = `refs['${ruleFnId}']`\n  const callable = `${rule}.validator(${variableName}.value, ${rule}.options, ${variableName});`\n\n  /**\n   * Add \"isValid\" condition when the bail flag is turned on.\n   */\n  const bailCondition = bail ? `${variableName}.isValid` : ''\n\n  /**\n   * Add the \"!is_[variableName]_missing\" conditional when the rule is not implicit.\n   */\n  const implicitCondition = implicit || dropMissingCheck ? '' : `${variableName}.isDefined`\n\n  /**\n   * Wrapping the validation invocation inside conditionals based upon\n   * enabled flags.\n   */\n  return wrapInConditional(\n    [bailCondition, implicitCondition],\n    isAsync ? `await ${callable}` : `${callable}`\n  )\n}\n\n/**\n * Returns JS fragment for executing validations for a given field.\n */\nexport function defineFieldValidations({\n  bail,\n  validations,\n  variableName,\n  dropMissingCheck,\n}: ValidationOptions) {\n  return `${validations\n    .map((one) => emitValidationSnippet(one, variableName, bail, dropMissingCheck))\n    .join('\\n')}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Options accepts by the output script\n */\ntype OutputOptions = {\n  variableName: string\n  outputExpression: string\n  outputValueExpression: string\n}\n\n/**\n * Returns JS fragment for writing the initial output for an array\n */\nexport function defineArrayInitialOutput({\n  variableName,\n  outputExpression,\n  outputValueExpression,\n}: OutputOptions) {\n  return `const ${variableName}_out = ${outputValueExpression};\n${outputExpression} = ${variableName}_out;`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype FieldOptions = {\n  variableName: string\n  isOptional: boolean\n  allowNull: boolean\n}\n\n/**\n * Returns JS fragment to validate a field's value for existence.\n */\nexport function defineFieldExistenceValidations({\n  allowNull,\n  isOptional,\n  variableName,\n}: FieldOptions): string {\n  /**\n   * Validations are only performed when `isOptional` flag\n   * is disabled.\n   */\n  if (isOptional === false) {\n    /**\n     * When `allowNull` flag is disabled, we should ensure the value\n     * is not null and neither undefined.\n     */\n    if (allowNull === false) {\n      return `ensureExists(${variableName});`\n    } else {\n      /**\n       * Otherwise ensure the value is not undefined.\n       */\n      return `ensureIsDefined(${variableName});`\n    }\n  }\n\n  return ''\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineArrayGuard } from '../../scripts/array/guard.js'\nimport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport type { CompilerField, CompilerParent, TupleNode } from '../../types.js'\nimport { defineArrayInitialOutput } from '../../scripts/array/initial_output.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\n/**\n * Compiles a tuple schema node to JS string output.\n */\nexport class TupleNodeCompiler extends BaseNode {\n  #node: TupleNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: TupleNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles the tuple children to a JS fragment\n   */\n  #compileTupleChildren() {\n    const buffer = this.#buffer.child()\n    const parent = {\n      type: 'tuple',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    } as const\n\n    this.#node.properties.forEach((child) => {\n      this.#compiler.compileNode(child, buffer, parent)\n    })\n\n    return buffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + tuple validation\n     * validation inside `if array field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isArrayValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineArrayInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: this.#node.allowUnknownProperties\n          ? `copyProperties(${this.field.variableName}.value)`\n          : `[]`,\n      })}${this.#compileTupleChildren()}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isArrayValidBlock\" inside\n     * `if value is array` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnArrayBlock = defineArrayGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${this.#buffer.newLine}${isArrayValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an array` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnArrayBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        variableName: this.field.variableName,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Options accepts by the loop script\n */\ntype ArrayLoopOptions = {\n  variableName: string\n  loopCodeSnippet: string\n  startingIndex?: number\n}\n\n/**\n * Returns JS fragment for wrapping code inside an array loop\n */\nexport function defineArrayLoop({\n  variableName,\n  loopCodeSnippet,\n  startingIndex,\n}: ArrayLoopOptions) {\n  startingIndex = startingIndex || 0\n  return `const ${variableName}_items_size = ${variableName}.value.length;\nfor (let ${variableName}_i = ${startingIndex}; ${variableName}_i < ${variableName}_items_size; ${variableName}_i++) {\n${loopCodeSnippet}\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineArrayLoop } from '../../scripts/array/loop.js'\nimport { defineArrayGuard } from '../../scripts/array/guard.js'\nimport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport type { CompilerField, CompilerParent, ArrayNode } from '../../types.js'\nimport { defineArrayInitialOutput } from '../../scripts/array/initial_output.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\n/**\n * Compiles an array schema node to JS string output.\n */\nexport class ArrayNodeCompiler extends BaseNode {\n  #node: ArrayNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: ArrayNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles the array elements to a JS fragment\n   */\n  #compileArrayElements() {\n    const arrayElementsBuffer = this.#buffer.child()\n    this.#compiler.compileNode(this.#node.each, arrayElementsBuffer, {\n      type: 'array',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    })\n\n    const buffer = this.#buffer.child()\n    buffer.writeStatement(\n      defineArrayLoop({\n        variableName: this.field.variableName,\n        startingIndex: 0,\n        loopCodeSnippet: arrayElementsBuffer.toString(),\n      })\n    )\n\n    arrayElementsBuffer.flush()\n    return buffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + array elements\n     * validation inside `if array field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isArrayValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineArrayInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: `[]`,\n      })}${this.#buffer.newLine}${this.#compileArrayElements()}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isArrayValidBlock\" inside\n     * `if value is array` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnArrayBlock = defineArrayGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${this.#buffer.newLine}${isArrayValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an array` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnArrayBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        variableName: this.field.variableName,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { RefIdentifier } from '../../types.js'\n\ntype FieldOptions = {\n  variableName: string\n  parseFnRefId?: RefIdentifier\n}\n\n/**\n * Returns JS fragment to call the parse function on the union conditional\n * schema.\n */\nexport function callParseFunction({ parseFnRefId, variableName }: FieldOptions) {\n  if (parseFnRefId) {\n    return `${variableName}.value = refs['${parseFnRefId}'](${variableName}.value);`\n  }\n  return ''\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ConditionalGuardOptions = {\n  variableName: string\n  conditionalFnRefId: string\n}\n\n/**\n * Returns JS fragment to invoke a function inside else block\n */\nexport function defineElseCondition({ variableName, conditionalFnRefId }: ConditionalGuardOptions) {\n  return `else {\nrefs['${conditionalFnRefId}'](${variableName}.value, ${variableName});\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ConditionalGuardOptions = {\n  variableName: string\n  conditionalFnRefId: string\n  guardedCodeSnippet: string\n  conditional: 'if' | 'else if'\n}\n\n/**\n * Returns JS fragment to wrap code inside a conditional guard\n */\nexport function defineConditionalGuard({\n  conditional,\n  variableName,\n  conditionalFnRefId,\n  guardedCodeSnippet,\n}: ConditionalGuardOptions) {\n  return `${conditional}(refs['${conditionalFnRefId}'](${variableName}.value, ${variableName})) {\n${guardedCodeSnippet}\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { callParseFunction } from '../../scripts/union/parse.js'\nimport { defineElseCondition } from '../../scripts/define_else_conditon.js'\nimport type { CompilerField, CompilerParent, UnionNode } from '../../types.js'\nimport { defineConditionalGuard } from '../../scripts/define_conditional_guard.js'\n\n/**\n * Compiles a union schema node to JS string output.\n */\nexport class UnionNodeCompiler extends BaseNode {\n  #compiler: Compiler\n  #node: UnionNode\n  #buffer: CompilerBuffer\n  #parent: CompilerParent\n\n  constructor(\n    node: UnionNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#parent = parent\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles union children by wrapping each conditon inside a conditional\n   * guard block\n   */\n  #compileUnionChildren() {\n    const childrenBuffer = this.#buffer.child()\n\n    this.#node.conditions.forEach((child, index) => {\n      const conditionalBuffer = this.#buffer.child()\n\n      /**\n       * Parse the value once the condition is true\n       */\n      if ('parseFnId' in child.schema) {\n        conditionalBuffer.writeStatement(\n          callParseFunction({\n            parseFnRefId: child.schema.parseFnId,\n            variableName: this.field.variableName,\n          })\n        )\n      }\n\n      this.#compiler.compileNode(child.schema, conditionalBuffer, this.#parent, this.field)\n\n      childrenBuffer.writeStatement(\n        defineConditionalGuard({\n          conditional: index === 0 ? 'if' : 'else if',\n          variableName: this.field.variableName,\n          conditionalFnRefId: child.conditionalFnRefId,\n          guardedCodeSnippet: conditionalBuffer.toString(),\n        })\n      )\n\n      conditionalBuffer.flush()\n    })\n\n    /**\n     * Define else block\n     */\n    if (this.#node.elseConditionalFnRefId && this.#node.conditions.length) {\n      childrenBuffer.writeStatement(\n        defineElseCondition({\n          variableName: this.field.variableName,\n          conditionalFnRefId: this.#node.elseConditionalFnRefId,\n        })\n      )\n    }\n\n    return childrenBuffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Compile union children wrapped inside predicate\n     * condition.\n     */\n    this.#buffer.writeStatement(this.#compileUnionChildren())\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Options accepts by the loop script\n */\ntype RecordLoopOptions = {\n  variableName: string\n  loopCodeSnippet: string\n}\n\n/**\n * Returns JS fragment for wrapping code inside an record loop\n */\nexport function defineRecordLoop({ variableName, loopCodeSnippet }: RecordLoopOptions) {\n  return `const ${variableName}_keys = Object.keys(${variableName}.value);\nconst ${variableName}_keys_size = ${variableName}_keys.length;\nfor (let ${variableName}_key_i = 0; ${variableName}_key_i < ${variableName}_keys_size; ${variableName}_key_i++) {\nconst ${variableName}_i = ${variableName}_keys[${variableName}_key_i];\n${loopCodeSnippet}\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ObjectGuardOptions = {\n  variableName: string\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside an object conditional\n */\nexport function defineObjectGuard({ variableName, guardedCodeSnippet }: ObjectGuardOptions) {\n  return `if (ensureIsObject(${variableName})) {\n${guardedCodeSnippet}\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Options accepts by the output script\n */\ntype OutputOptions = {\n  variableName: string\n  outputExpression: string\n  outputValueExpression: string\n}\n\n/**\n * Returns JS fragment for writing the initial output for an object\n */\nexport function defineObjectInitialOutput({\n  variableName,\n  outputExpression,\n  outputValueExpression,\n}: OutputOptions) {\n  return `const ${variableName}_out = ${outputValueExpression};\n${outputExpression} = ${variableName}_out;`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineRecordLoop } from '../../scripts/record/loop.js'\nimport { defineObjectGuard } from '../../scripts/object/guard.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport type { CompilerField, CompilerParent, RecordNode } from '../../types.js'\nimport { defineObjectInitialOutput } from '../../scripts/object/initial_output.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\n/**\n * Compiles a record schema node to JS string output.\n */\nexport class RecordNodeCompiler extends BaseNode {\n  #node: RecordNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: RecordNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles the record elements to a JS fragment\n   */\n  #compileRecordElements() {\n    const buffer = this.#buffer.child()\n    const recordElementsBuffer = this.#buffer.child()\n\n    this.#compiler.compileNode(this.#node.each, recordElementsBuffer, {\n      type: 'record',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    })\n\n    buffer.writeStatement(\n      defineRecordLoop({\n        variableName: this.field.variableName,\n        loopCodeSnippet: recordElementsBuffer.toString(),\n      })\n    )\n\n    recordElementsBuffer.flush()\n    return buffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + tuple validation + array elements\n     * validation inside `if array field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isObjectValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineObjectInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: `{}`,\n      })}${this.#compileRecordElements()}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isArrayValidBlock\" inside\n     * `if value is array` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnObjectBlock = defineObjectGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${this.#buffer.newLine}${isObjectValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an object` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnObjectBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        variableName: this.field.variableName,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Options accepts by the output script\n */\ntype MovePropertiesOptions = {\n  variableName: string\n  allowUnknownProperties: boolean\n  fieldsToIgnore: string[]\n}\n\n/**\n * Converts an array of strings to a string representation\n * like [\"foo\", \"bar\"]. Just like node:inspect does.\n */\nfunction arrayToString(arr: string[]) {\n  return `[${arr.map((str) => `\"${str}\"`).join(', ')}]`\n}\n\n/**\n * Returns JS fragment for moving properties from the source\n * to destination\n */\nexport function defineMoveProperties({\n  variableName,\n  fieldsToIgnore,\n  allowUnknownProperties,\n}: MovePropertiesOptions) {\n  if (!allowUnknownProperties) {\n    return ''\n  }\n\n  const serializedFieldsToIgnore = arrayToString(fieldsToIgnore)\n  return `moveProperties(${variableName}.value, ${variableName}_out, ${serializedFieldsToIgnore});`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineObjectGuard } from '../../scripts/object/guard.js'\nimport { defineElseCondition } from '../../scripts/define_else_conditon.js'\nimport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport { defineConditionalGuard } from '../../scripts/define_conditional_guard.js'\nimport { defineObjectInitialOutput } from '../../scripts/object/initial_output.js'\nimport { defineMoveProperties } from '../../scripts/object/move_unknown_properties.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\nimport type { CompilerField, CompilerParent, ObjectNode, ObjectGroupNode } from '../../types.js'\n\n/**\n * Compiles an object schema node to JS string output.\n */\nexport class ObjectNodeCompiler extends BaseNode {\n  #node: ObjectNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: ObjectNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Returns known field names for the object\n   */\n  #getFieldNames(node: Pick<ObjectNode, 'properties' | 'groups'>): string[] {\n    let fieldNames = node.properties.map((child) => child.fieldName)\n    const groupsFieldNames = node.groups.flatMap((group) => this.#getGroupFieldNames(group))\n    return fieldNames.concat(groupsFieldNames)\n  }\n\n  /**\n   * Returns field names of a group.\n   */\n  #getGroupFieldNames(group: ObjectGroupNode): string[] {\n    return group.conditions.flatMap((condition) => {\n      return this.#getFieldNames(condition.schema)\n    })\n  }\n\n  /**\n   * Compiles object children to JS output\n   */\n  #compileObjectChildren() {\n    const buffer = this.#buffer.child()\n    const parent = {\n      type: 'object',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    } as const\n\n    this.#node.properties.forEach((child) => this.#compiler.compileNode(child, buffer, parent))\n    return buffer.toString()\n  }\n\n  /**\n   * Compiles object groups with conditions to JS output.\n   */\n  #compileObjectGroups() {\n    const buffer = this.#buffer.child()\n    const parent = {\n      type: 'object',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    } as const\n    this.#node.groups.forEach((group) => this.#compileObjectGroup(group, buffer, parent))\n    return buffer.toString()\n  }\n\n  /**\n   * Compiles an object groups recursively\n   */\n  #compileObjectGroup(group: ObjectGroupNode, buffer: CompilerBuffer, parent: CompilerParent) {\n    group.conditions.forEach((condition, index) => {\n      const guardBuffer = buffer.child()\n\n      condition.schema.properties.forEach((child) => {\n        this.#compiler.compileNode(child, guardBuffer, parent)\n      })\n\n      condition.schema.groups.forEach((child) => {\n        this.#compileObjectGroup(child, guardBuffer, parent)\n      })\n\n      buffer.writeStatement(\n        defineConditionalGuard({\n          variableName: this.field.variableName,\n          conditional: index === 0 ? 'if' : 'else if',\n          conditionalFnRefId: condition.conditionalFnRefId,\n          guardedCodeSnippet: guardBuffer.toString(),\n        })\n      )\n    })\n\n    /**\n     * Define else block\n     */\n    if (group.elseConditionalFnRefId && group.conditions.length) {\n      buffer.writeStatement(\n        defineElseCondition({\n          variableName: this.field.variableName,\n          conditionalFnRefId: group.elseConditionalFnRefId,\n        })\n      )\n    }\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + object children validations\n     * validation inside `if object field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isObjectValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineObjectInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: '{}',\n      })}${this.#buffer.newLine}${this.#compileObjectChildren()}${\n        this.#buffer.newLine\n      }${this.#compileObjectGroups()}${this.#buffer.newLine}${defineMoveProperties({\n        variableName: this.field.variableName,\n        allowUnknownProperties: this.#node.allowUnknownProperties,\n        fieldsToIgnore: this.#node.allowUnknownProperties ? this.#getFieldNames(this.#node) : [],\n      })}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isObjectValidBlock\" inside\n     * `if value is object` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnObject = defineObjectGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${isObjectValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an object` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnObject}${this.#buffer.newLine}${defineFieldNullOutput({\n        variableName: this.field.variableName,\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, CompilerParent } from '../../types.js'\n\nexport function createRootField(parent: CompilerParent): CompilerField {\n  return {\n    parentExpression: parent.variableName,\n    parentValueExpression: parent.variableName,\n    fieldNameExpression: `''`,\n    fieldPathExpression: `''`,\n    wildCardPath: '',\n    variableName: `${parent.variableName}_item`,\n    valueExpression: 'root',\n    outputExpression: parent.outputExpression,\n    isArrayMember: false,\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { RefIdentifier } from '../../types.js'\n\n/**\n * Options accepts by the output script\n */\ntype OutputOptions = {\n  outputExpression: string\n  variableName: string\n  transformFnRefId?: RefIdentifier\n}\n\n/**\n * Returns JS fragment for writing the validated value to the output.\n */\nexport function defineFieldValueOutput({\n  variableName,\n  outputExpression,\n  transformFnRefId,\n}: OutputOptions) {\n  const outputValueExpression = transformFnRefId\n    ? `refs['${transformFnRefId}'](${variableName}.value, ${variableName})`\n    : `${variableName}.value`\n\n  return `if (${variableName}.isDefined && ${variableName}.isValid) {\n  ${outputExpression} = ${outputValueExpression};\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineFieldValueOutput } from '../../scripts/field/value_output.js'\nimport type { LiteralNode, CompilerParent, CompilerField } from '../../types.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\n/**\n * Compiles a literal schema node to JS string output.\n */\nexport class LiteralNodeCompiler extends BaseNode {\n  #node: LiteralNode\n  #buffer: CompilerBuffer\n\n  constructor(\n    node: LiteralNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define block to validate the existence of field\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Step 3: Define code to run validations on field\n     */\n    this.#buffer.writeStatement(\n      defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: false,\n      })\n    )\n\n    /**\n     * Step 4: Define block to save the output value or the null value\n     */\n    this.#buffer.writeStatement(\n      `${defineFieldValueOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        transformFnRefId: this.#node.transformFnId,\n      })}${this.#buffer.newLine}${defineFieldNullOutput({\n        variableName: this.field.variableName,\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        transformFnRefId: this.#node.transformFnId,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, CompilerParent } from '../../types.js'\n\nexport function createArrayField(parent: CompilerParent): CompilerField {\n  const wildCardPath = parent.wildCardPath !== '' ? `${parent.wildCardPath}.*` : `*`\n\n  return {\n    parentExpression: parent.variableName,\n    parentValueExpression: `${parent.variableName}.value`,\n    fieldNameExpression: `${parent.variableName}_i`,\n    fieldPathExpression: wildCardPath,\n    wildCardPath: wildCardPath,\n    variableName: `${parent.variableName}_item`,\n    valueExpression: `${parent.variableName}.value[${parent.variableName}_i]`,\n    outputExpression: `${parent.variableName}_out[${parent.variableName}_i]`,\n    isArrayMember: true,\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, FieldNode, CompilerParent } from '../../types.js'\n\nexport function createTupleField(\n  node: Pick<FieldNode, 'fieldName' | 'propertyName'>,\n  parent: CompilerParent\n): CompilerField {\n  const wildCardPath =\n    parent.wildCardPath !== '' ? `${parent.wildCardPath}.${node.fieldName}` : node.fieldName\n\n  return {\n    parentExpression: parent.variableName,\n    parentValueExpression: `${parent.variableName}.value`,\n    fieldNameExpression: `${node.fieldName}`,\n    fieldPathExpression: wildCardPath,\n    wildCardPath: wildCardPath,\n    variableName: `${parent.variableName}_item_${node.fieldName}`,\n    valueExpression: `${parent.variableName}.value[${node.fieldName}]`,\n    outputExpression: `${parent.variableName}_out[${node.propertyName}]`,\n    isArrayMember: true,\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Returns JS fragment to report errors\n */\nexport function reportErrors() {\n  return `if(errorReporter.hasErrors) {\n  throw errorReporter.createError();\n}`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, FieldNode, CompilerParent } from '../../types.js'\n\nexport function createObjectField(\n  node: Pick<FieldNode, 'fieldName' | 'propertyName'>,\n  variablesCounter: number,\n  parent: CompilerParent\n): CompilerField {\n  const wildCardPath =\n    parent.wildCardPath !== '' ? `${parent.wildCardPath}.${node.fieldName}` : node.fieldName\n\n  return {\n    parentExpression: parent.variableName,\n    parentValueExpression: `${parent.variableName}.value`,\n    fieldNameExpression: `'${node.fieldName}'`,\n    fieldPathExpression: wildCardPath,\n    wildCardPath: wildCardPath,\n    variableName: `${node.propertyName}_${variablesCounter}`,\n    valueExpression: `${parent.variableName}.value['${node.fieldName}']`,\n    outputExpression: `${parent.variableName}_out['${node.propertyName}']`,\n    isArrayMember: false,\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, CompilerParent } from '../../types.js'\n\nexport function createRecordField(parent: CompilerParent): CompilerField {\n  const wildCardPath = parent.wildCardPath !== '' ? `${parent.wildCardPath}.*` : `*`\n\n  return {\n    parentExpression: parent.variableName,\n    parentValueExpression: `${parent.variableName}.value`,\n    fieldNameExpression: `${parent.variableName}_i`,\n    fieldPathExpression: wildCardPath,\n    wildCardPath: wildCardPath,\n    variableName: `${parent.variableName}_item`,\n    valueExpression: `${parent.variableName}.value[${parent.variableName}_i]`,\n    outputExpression: `${parent.variableName}_out[${parent.variableName}_i]`,\n    isArrayMember: false,\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Returns JS fragment for inline function needed by the\n * validation runtime code.\n */\nexport function defineInlineFunctions(options: { convertEmptyStringsToNull: boolean }) {\n  return `function report(message, rule, field, args) {\n  field.isValid = false;\n  errorReporter.report(messagesProvider.getMessage(message, rule, field, args), rule, field, args);\n};\nfunction defineValue(value, field) {\n  ${options.convertEmptyStringsToNull ? `if (value === '') { value = null; }` : ''}\n  field.value = value;\n  field.isDefined = value !== undefined && value !== null;\n  return field;\n};\nfunction ensureExists(field) {\n  if (field.value === undefined || field.value === null) {\n    field.report(REQUIRED, 'required', field);\n    return false;\n  }\n  return true;\n};\nfunction ensureIsDefined(field) {\n  if (field.value === undefined) {\n    field.report(REQUIRED, 'required', field);\n    return false;\n  }\n  return true;\n};\nfunction ensureIsObject(field) {\n  if (!field.isDefined) {\n    return false;\n  }\n  if (typeof field.value == 'object' && !Array.isArray(field.value)) {\n    return true;\n  }\n  field.report(NOT_AN_OBJECT, 'object', field);\n  return false;\n};\nfunction ensureIsArray(field) {\n  if (!field.isDefined) {\n    return false;\n  }\n  if (Array.isArray(field.value)) {\n    return true;\n  }\n  field.report(NOT_AN_ARRAY, 'array', field);\n  return false;\n};\nfunction copyProperties(val) {\n  let k, out, tmp;\n\n  if (Array.isArray(val)) {\n    out = Array((k = val.length))\n    while (k--) out[k] = (tmp = val[k]) && typeof tmp == 'object' ? copyProperties(tmp) : tmp\n    return out\n  }\n\n  if (Object.prototype.toString.call(val) === '[object Object]') {\n    out = {} // null\n    for (k in val) {\n      out[k] = (tmp = val[k]) && typeof tmp == 'object' ? copyProperties(tmp) : tmp\n    }\n    return out\n  }\n  return val\n};\nfunction moveProperties(source, destination, ignoreKeys) {\n  for (let key in source) {\n    if (!ignoreKeys.includes(key)) {\n      const value = source[key]\n      destination[key] = copyProperties(value)\n    }\n  }\n};`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { CompilerOptions } from '../types.js'\n\n/**\n * Returns JS fragment for inline error messages for errors raised\n * by the compiler.\n */\nexport function defineInlineErrorMessages(\n  messages: Required<Exclude<CompilerOptions['messages'], undefined>>\n) {\n  return `const REQUIRED = '${messages.required}';\nconst NOT_AN_OBJECT = '${messages.object}';\nconst NOT_AN_ARRAY = '${messages.array}';`\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { CompilerBuffer } from './buffer.js'\nimport { TupleNodeCompiler } from './nodes/tuple.js'\nimport { ArrayNodeCompiler } from './nodes/array.js'\nimport { UnionNodeCompiler } from './nodes/union.js'\nimport { RecordNodeCompiler } from './nodes/record.js'\nimport { ObjectNodeCompiler } from './nodes/object.js'\nimport { createRootField } from './fields/root_field.js'\nimport { LiteralNodeCompiler } from './nodes/literal.js'\nimport { createArrayField } from './fields/array_field.js'\nimport { createTupleField } from './fields/tuple_field.js'\nimport { reportErrors } from '../scripts/report_errors.js'\nimport { createObjectField } from './fields/object_field.js'\nimport { createRecordField } from './fields/record_field.js'\nimport { defineInlineFunctions } from '../scripts/define_inline_functions.js'\nimport { defineInlineErrorMessages } from '../scripts/define_error_messages.js'\nimport type {\n  Refs,\n  RootNode,\n  CompilerField,\n  CompilerNodes,\n  CompilerParent,\n  CompilerOptions,\n  ErrorReporterContract,\n  MessagesProviderContact,\n} from '../types.js'\n\n/**\n * Representation of an async function\n */\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\n\n/**\n * Compiler is used to compile an array of schema nodes into a re-usable\n * JavaScript.\n */\nexport class Compiler {\n  /**\n   * Variables counter is used to generate unique variable\n   * names with a counter suffix.\n   */\n  variablesCounter: number = 0\n\n  /**\n   * An array of nodes to process\n   */\n  #rootNode: RootNode\n\n  /**\n   * Options to configure the compiler behavior\n   */\n  #options: CompilerOptions\n\n  /**\n   * Buffer for collection the JS output string\n   */\n  #buffer: CompilerBuffer = new CompilerBuffer()\n\n  constructor(rootNode: RootNode, options?: CompilerOptions) {\n    this.#rootNode = rootNode\n    this.#options = options || { convertEmptyStringsToNull: false }\n  }\n\n  /**\n   * Initiates the JS output\n   */\n  #initiateJSOutput() {\n    this.#buffer.writeStatement(\n      defineInlineErrorMessages({\n        required: 'value is required',\n        object: 'value is not a valid object',\n        array: 'value is not a valid array',\n        ...this.#options.messages,\n      })\n    )\n    this.#buffer.writeStatement(defineInlineFunctions(this.#options))\n    this.#buffer.writeStatement('let out;')\n  }\n\n  /**\n   * Finished the JS output\n   */\n  #finishJSOutput() {\n    this.#buffer.writeStatement(reportErrors())\n    this.#buffer.writeStatement('return out;')\n  }\n\n  /**\n   * Compiles all the nodes\n   */\n  #compileNodes() {\n    this.compileNode(this.#rootNode.schema, this.#buffer, {\n      type: 'root',\n      variableName: 'root',\n      outputExpression: 'out',\n      fieldPathExpression: 'out',\n      wildCardPath: '',\n    })\n  }\n\n  /**\n   * Returns compiled output as a function\n   */\n  #toAsyncFunction<T extends Record<string, any>>(): (\n    data: any,\n    meta: Record<string, any>,\n    refs: Refs,\n    messagesProvider: MessagesProviderContact,\n    errorReporter: ErrorReporterContract\n  ) => Promise<T> {\n    return new AsyncFunction(\n      'root',\n      'meta',\n      'refs',\n      'messagesProvider',\n      'errorReporter',\n      this.#buffer.toString()\n    )\n  }\n\n  /**\n   * Converts a node to a field. Optionally accepts a parent node to create\n   * a field for a specific parent type.\n   */\n  createFieldFor(node: CompilerNodes, parent: CompilerParent) {\n    switch (parent.type) {\n      case 'array':\n        return createArrayField(parent)\n      case 'root':\n        return createRootField(parent)\n      case 'object':\n        return createObjectField(node, this.variablesCounter, parent)\n      case 'tuple':\n        return createTupleField(node, parent)\n      case 'record':\n        return createRecordField(parent)\n    }\n  }\n\n  /**\n   * Compiles a given compiler node\n   */\n  compileNode(\n    node: CompilerNodes,\n    buffer: CompilerBuffer,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    switch (node.type) {\n      case 'literal':\n        return new LiteralNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'array':\n        return new ArrayNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'record':\n        return new RecordNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'object':\n        return new ObjectNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'tuple':\n        return new TupleNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'union':\n        return new UnionNodeCompiler(node, buffer, this, parent, parentField).compile()\n    }\n  }\n\n  /**\n   * Compile schema nodes to an async function\n   */\n  compile() {\n    this.#initiateJSOutput()\n    this.#compileNodes()\n    this.#finishJSOutput()\n\n    const outputFunction = this.#toAsyncFunction()\n\n    this.variablesCounter = 0\n    this.#buffer.flush()\n\n    return outputFunction\n  }\n}\n","/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type {\n  Refs,\n  ParseFn,\n  RefsStore,\n  TransformFn,\n  ConditionalFn,\n  RefIdentifier,\n  ValidationRule,\n} from './types.js'\n\n/**\n * Creates a refs store for parsing the schema\n */\nexport function refsBuilder(): RefsStore {\n  let counter = 0\n  const refs: Refs = {}\n\n  return {\n    toJSON() {\n      return refs\n    },\n\n    /**\n     * Track a value inside refs\n     */\n    track(value: Refs[keyof Refs]): RefIdentifier {\n      counter++\n      const ref = `ref://${counter}` as const\n      refs[ref] = value\n      return ref\n    },\n\n    /**\n     * Track a validation inside refs\n     */\n    trackValidation(validation: ValidationRule): RefIdentifier {\n      return this.track(validation)\n    },\n\n    /**\n     * Track input value parser inside refs\n     */\n    trackParser(fn: ParseFn): RefIdentifier {\n      return this.track(fn)\n    },\n\n    /**\n     * Track output value transformer inside refs\n     */\n    trackTransformer(fn: TransformFn<any, any>): RefIdentifier {\n      return this.track(fn)\n    },\n\n    /**\n     * Track a conditional inside refs\n     */\n    trackConditional(fn: ConditionalFn<any>): RefIdentifier {\n      return this.track(fn)\n    },\n  }\n}\n"],"mappings":";AAYO,IAAM,iBAAN,MAAM,gBAAe;AAAA,EAC1B,WAAmB;AAAA;AAAA;AAAA;AAAA,EAKnB,UAAU;AAAA;AAAA;AAAA;AAAA,EAKV,eAAe,WAAmB;AAChC,SAAK,WAAW,GAAG,KAAK,QAAQ,GAAG,KAAK,OAAO,GAAG,SAAS;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,WAAO,IAAI,gBAAe;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,SAAK,WAAW;AAAA,EAClB;AACF;;;ACpBO,SAAS,qBAAqB;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAiB;AACf,QAAM,oBAAoB,eACtB,SAAS,YAAY,MAAM,eAAe;AAAA;AAAA;AAAA,gBAGhC,qBAAqB;AAAA,UAE/B;AAOJ,MAAI,4BAA4B;AAMhC,MAAI,qBAAqB,UAAU,qBAAqB,aAAa;AACnE,gCAA4B;AAAA,EAC9B,WAAW,wBAAwB,MAAM;AAKvC,gCAA4B,GAAG,gBAAgB,2BAA2B,mBAAmB;AAAA,EAC/F;AAEA,SAAO,SAAS,YAAY,kBAAkB,iBAAiB;AAAA;AAAA;AAAA,UAGvD,mBAAmB;AAAA,mBACV,YAAY;AAAA;AAAA,aAElB,yBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA,YAK1B,qBAAqB;AAAA,mBACd,aAAa;AAAA;AAEhC;;;AClEO,IAAe,WAAf,MAAwB;AAAA,EAC7B;AAAA,EACA;AAAA,EACU;AAAA,EAEV,YACE,MACA,UACA,QACA,aACA;AACA,SAAK,eAAe;AACpB,SAAK,QAAQ;AAEb,QAAI,KAAK,cAAc;AACrB,WAAK,QAAQ,KAAK;AAAA,IACpB,OAAO;AACL,eAAS;AACT,WAAK,QAAQ,SAAS,eAAe,MAAM,MAAM;AAAA,IACnD;AAAA,EACF;AAAA,EAEU,YAAY,QAAwB;AAC5C,QAAI,CAAC,KAAK,cAAc;AACtB,aAAO;AAAA,QACL,qBAAqB;AAAA,UACnB,qBAAqB,KAAK,MAAM;AAAA,UAChC,eAAe,KAAK,MAAM;AAAA,UAC1B,kBAAkB,KAAK,MAAM;AAAA,UAC7B,uBAAuB,KAAK,MAAM;AAAA,UAClC,iBAAiB,KAAK,MAAM;AAAA,UAC5B,cAAc,KAAK,MAAM;AAAA,UACzB,cAAc,KAAK,MAAM;AAAA,UACzB,cAAc,eAAe,KAAK,QAAQ,KAAK,MAAM,YAAY;AAAA,QACnE,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;;;ACnCO,SAAS,iBAAiB,EAAE,cAAc,mBAAmB,GAAsB;AACxF,SAAO,qBAAqB,YAAY;AAAA,EACxC,kBAAkB;AAAA;AAEpB;;;ACHO,SAAS,mBAAmB,EAAE,cAAc,MAAM,mBAAmB,GAAuB;AACjG,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAEA,SAAO,OAAO,YAAY;AAAA,EAC1B,kBAAkB;AAAA;AAEpB;;;ACDO,SAAS,sBAAsB;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAkB;AAChB,MAAI,CAAC,WAAW;AACd,WAAO;AAAA,EACT;AAEA,SAAO,GAAG,eAAe,IAAI,IAAI,YAAY;AAAA,IAC3C,gBAAgB,MAChB,mBAAmB,SAAS,gBAAgB,YAAY,YAAY,OAAO,OAC7E;AAAA;AAEF;;;ACZA,SAAS,kBAAkB,YAA8B,cAAsB;AAC7E,QAAM,CAAC,OAAO,MAAM,IAAI;AACxB,MAAI,SAAS,QAAQ;AACnB,WAAO,OAAO,KAAK,OAAO,MAAM;AAAA,IAChC,YAAY;AAAA;AAAA,EAEd;AAEA,MAAI,OAAO;AACT,WAAO,OAAO,KAAK;AAAA,IACnB,YAAY;AAAA;AAAA,EAEd;AAEA,MAAI,QAAQ;AACV,WAAO,OAAO,MAAM;AAAA,IACpB,YAAY;AAAA;AAAA,EAEd;AAEA,SAAO;AACT;AAKA,SAAS,sBACP,EAAE,SAAS,UAAU,SAAS,GAC9B,cACA,MACA,kBACA;AACA,QAAM,OAAO,SAAS,QAAQ;AAC9B,QAAM,WAAW,GAAG,IAAI,cAAc,YAAY,WAAW,IAAI,aAAa,YAAY;AAK1F,QAAM,gBAAgB,OAAO,GAAG,YAAY,aAAa;AAKzD,QAAM,oBAAoB,YAAY,mBAAmB,KAAK,GAAG,YAAY;AAM7E,SAAO;AAAA,IACL,CAAC,eAAe,iBAAiB;AAAA,IACjC,UAAU,SAAS,QAAQ,KAAK,GAAG,QAAQ;AAAA,EAC7C;AACF;AAKO,SAAS,uBAAuB;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAsB;AACpB,SAAO,GAAG,YACP,IAAI,CAAC,QAAQ,sBAAsB,KAAK,cAAc,MAAM,gBAAgB,CAAC,EAC7E,KAAK,IAAI,CAAC;AACf;;;AC3EO,SAAS,yBAAyB;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AACF,GAAkB;AAChB,SAAO,SAAS,YAAY,UAAU,qBAAqB;AAAA,EAC3D,gBAAgB,MAAM,YAAY;AACpC;;;ACVO,SAAS,gCAAgC;AAAA,EAC9C;AAAA,EACA;AAAA,EACA;AACF,GAAyB;AAKvB,MAAI,eAAe,OAAO;AAKxB,QAAI,cAAc,OAAO;AACvB,aAAO,gBAAgB,YAAY;AAAA,IACrC,OAAO;AAIL,aAAO,mBAAmB,YAAY;AAAA,IACxC;AAAA,EACF;AAEA,SAAO;AACT;;;ACpBO,IAAM,oBAAN,cAAgC,SAAS;AAAA,EAC9C;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YACE,MACA,QACA,UACA,QACA,aACA;AACA,UAAM,MAAM,UAAU,QAAQ,WAAW;AACzC,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,wBAAwB;AACtB,UAAM,SAAS,KAAK,QAAQ,MAAM;AAClC,UAAM,SAAS;AAAA,MACb,MAAM;AAAA,MACN,qBAAqB,KAAK,MAAM;AAAA,MAChC,kBAAkB,KAAK,MAAM;AAAA,MAC7B,cAAc,KAAK,MAAM;AAAA,MACzB,cAAc,KAAK,MAAM;AAAA,IAC3B;AAEA,SAAK,MAAM,WAAW,QAAQ,CAAC,UAAU;AACvC,WAAK,UAAU,YAAY,OAAO,QAAQ,MAAM;AAAA,IAClD,CAAC;AAED,WAAO,OAAO,SAAS;AAAA,EACzB;AAAA,EAEA,UAAU;AAIR,SAAK,YAAY,KAAK,OAAO;AAK7B,SAAK,QAAQ;AAAA,MACX,gCAAgC;AAAA,QAC9B,WAAW,KAAK,MAAM;AAAA,QACtB,YAAY,KAAK,MAAM;AAAA,QACvB,cAAc,KAAK,MAAM;AAAA,MAC3B,CAAC;AAAA,IACH;AAQA,UAAM,oBAAoB,mBAAmB;AAAA,MAC3C,cAAc,KAAK,MAAM;AAAA,MACzB,MAAM,KAAK,MAAM;AAAA,MACjB,oBAAoB,GAAG,yBAAyB;AAAA,QAC9C,cAAc,KAAK,MAAM;AAAA,QACzB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,uBAAuB,KAAK,MAAM,yBAC9B,kBAAkB,KAAK,MAAM,YAAY,YACzC;AAAA,MACN,CAAC,CAAC,GAAG,KAAK,sBAAsB,CAAC;AAAA,IACnC,CAAC;AAQD,UAAM,sBAAsB,iBAAiB;AAAA,MAC3C,cAAc,KAAK,MAAM;AAAA,MACzB,oBAAoB,GAAG,uBAAuB;AAAA,QAC5C,cAAc,KAAK,MAAM;AAAA,QACzB,aAAa,KAAK,MAAM;AAAA,QACxB,MAAM,KAAK,MAAM;AAAA,QACjB,kBAAkB;AAAA,MACpB,CAAC,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,iBAAiB;AAAA,IAC/C,CAAC;AAMD,SAAK,QAAQ;AAAA,MACX,GAAG,mBAAmB,GAAG,KAAK,QAAQ,OAAO,GAAG,sBAAsB;AAAA,QACpE,WAAW,KAAK,MAAM;AAAA,QACtB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,cAAc,KAAK,MAAM;AAAA,QACzB,aAAa;AAAA,MACf,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AACF;;;ACxGO,SAAS,gBAAgB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AACF,GAAqB;AACnB,kBAAgB,iBAAiB;AACjC,SAAO,SAAS,YAAY,iBAAiB,YAAY;AAAA,WAChD,YAAY,QAAQ,aAAa,KAAK,YAAY,QAAQ,YAAY,gBAAgB,YAAY;AAAA,EAC3G,eAAe;AAAA;AAEjB;;;ACPO,IAAM,oBAAN,cAAgC,SAAS;AAAA,EAC9C;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YACE,MACA,QACA,UACA,QACA,aACA;AACA,UAAM,MAAM,UAAU,QAAQ,WAAW;AACzC,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,wBAAwB;AACtB,UAAM,sBAAsB,KAAK,QAAQ,MAAM;AAC/C,SAAK,UAAU,YAAY,KAAK,MAAM,MAAM,qBAAqB;AAAA,MAC/D,MAAM;AAAA,MACN,qBAAqB,KAAK,MAAM;AAAA,MAChC,kBAAkB,KAAK,MAAM;AAAA,MAC7B,cAAc,KAAK,MAAM;AAAA,MACzB,cAAc,KAAK,MAAM;AAAA,IAC3B,CAAC;AAED,UAAM,SAAS,KAAK,QAAQ,MAAM;AAClC,WAAO;AAAA,MACL,gBAAgB;AAAA,QACd,cAAc,KAAK,MAAM;AAAA,QACzB,eAAe;AAAA,QACf,iBAAiB,oBAAoB,SAAS;AAAA,MAChD,CAAC;AAAA,IACH;AAEA,wBAAoB,MAAM;AAC1B,WAAO,OAAO,SAAS;AAAA,EACzB;AAAA,EAEA,UAAU;AAIR,SAAK,YAAY,KAAK,OAAO;AAK7B,SAAK,QAAQ;AAAA,MACX,gCAAgC;AAAA,QAC9B,WAAW,KAAK,MAAM;AAAA,QACtB,YAAY,KAAK,MAAM;AAAA,QACvB,cAAc,KAAK,MAAM;AAAA,MAC3B,CAAC;AAAA,IACH;AAQA,UAAM,oBAAoB,mBAAmB;AAAA,MAC3C,cAAc,KAAK,MAAM;AAAA,MACzB,MAAM,KAAK,MAAM;AAAA,MACjB,oBAAoB,GAAG,yBAAyB;AAAA,QAC9C,cAAc,KAAK,MAAM;AAAA,QACzB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,uBAAuB;AAAA,MACzB,CAAC,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,KAAK,sBAAsB,CAAC;AAAA,IAC1D,CAAC;AAQD,UAAM,sBAAsB,iBAAiB;AAAA,MAC3C,cAAc,KAAK,MAAM;AAAA,MACzB,oBAAoB,GAAG,uBAAuB;AAAA,QAC5C,cAAc,KAAK,MAAM;AAAA,QACzB,aAAa,KAAK,MAAM;AAAA,QACxB,MAAM,KAAK,MAAM;AAAA,QACjB,kBAAkB;AAAA,MACpB,CAAC,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,iBAAiB;AAAA,IAC/C,CAAC;AAMD,SAAK,QAAQ;AAAA,MACX,GAAG,mBAAmB,GAAG,KAAK,QAAQ,OAAO,GAAG,sBAAsB;AAAA,QACpE,WAAW,KAAK,MAAM;AAAA,QACtB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,cAAc,KAAK,MAAM;AAAA,QACzB,aAAa;AAAA,MACf,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AACF;;;AC9GO,SAAS,kBAAkB,EAAE,cAAc,aAAa,GAAiB;AAC9E,MAAI,cAAc;AAChB,WAAO,GAAG,YAAY,kBAAkB,YAAY,MAAM,YAAY;AAAA,EACxE;AACA,SAAO;AACT;;;ACRO,SAAS,oBAAoB,EAAE,cAAc,mBAAmB,GAA4B;AACjG,SAAO;AAAA,QACD,kBAAkB,MAAM,YAAY,WAAW,YAAY;AAAA;AAEnE;;;ACFO,SAAS,uBAAuB;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAA4B;AAC1B,SAAO,GAAG,WAAW,UAAU,kBAAkB,MAAM,YAAY,WAAW,YAAY;AAAA,EAC1F,kBAAkB;AAAA;AAEpB;;;ACRO,IAAM,oBAAN,cAAgC,SAAS;AAAA,EAC9C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YACE,MACA,QACA,UACA,QACA,aACA;AACA,UAAM,MAAM,UAAU,QAAQ,WAAW;AACzC,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,wBAAwB;AACtB,UAAM,iBAAiB,KAAK,QAAQ,MAAM;AAE1C,SAAK,MAAM,WAAW,QAAQ,CAAC,OAAO,UAAU;AAC9C,YAAM,oBAAoB,KAAK,QAAQ,MAAM;AAK7C,UAAI,eAAe,MAAM,QAAQ;AAC/B,0BAAkB;AAAA,UAChB,kBAAkB;AAAA,YAChB,cAAc,MAAM,OAAO;AAAA,YAC3B,cAAc,KAAK,MAAM;AAAA,UAC3B,CAAC;AAAA,QACH;AAAA,MACF;AAEA,WAAK,UAAU,YAAY,MAAM,QAAQ,mBAAmB,KAAK,SAAS,KAAK,KAAK;AAEpF,qBAAe;AAAA,QACb,uBAAuB;AAAA,UACrB,aAAa,UAAU,IAAI,OAAO;AAAA,UAClC,cAAc,KAAK,MAAM;AAAA,UACzB,oBAAoB,MAAM;AAAA,UAC1B,oBAAoB,kBAAkB,SAAS;AAAA,QACjD,CAAC;AAAA,MACH;AAEA,wBAAkB,MAAM;AAAA,IAC1B,CAAC;AAKD,QAAI,KAAK,MAAM,0BAA0B,KAAK,MAAM,WAAW,QAAQ;AACrE,qBAAe;AAAA,QACb,oBAAoB;AAAA,UAClB,cAAc,KAAK,MAAM;AAAA,UACzB,oBAAoB,KAAK,MAAM;AAAA,QACjC,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,eAAe,SAAS;AAAA,EACjC;AAAA,EAEA,UAAU;AAIR,SAAK,YAAY,KAAK,OAAO;AAM7B,SAAK,QAAQ,eAAe,KAAK,sBAAsB,CAAC;AAAA,EAC1D;AACF;;;ACnFO,SAAS,iBAAiB,EAAE,cAAc,gBAAgB,GAAsB;AACrF,SAAO,SAAS,YAAY,uBAAuB,YAAY;AAAA,QACzD,YAAY,gBAAgB,YAAY;AAAA,WACrC,YAAY,eAAe,YAAY,YAAY,YAAY,eAAe,YAAY;AAAA,QAC7F,YAAY,QAAQ,YAAY,SAAS,YAAY;AAAA,EAC3D,eAAe;AAAA;AAEjB;;;ACVO,SAAS,kBAAkB,EAAE,cAAc,mBAAmB,GAAuB;AAC1F,SAAO,sBAAsB,YAAY;AAAA,EACzC,kBAAkB;AAAA;AAEpB;;;ACAO,SAAS,0BAA0B;AAAA,EACxC;AAAA,EACA;AAAA,EACA;AACF,GAAkB;AAChB,SAAO,SAAS,YAAY,UAAU,qBAAqB;AAAA,EAC3D,gBAAgB,MAAM,YAAY;AACpC;;;ACJO,IAAM,qBAAN,cAAiC,SAAS;AAAA,EAC/C;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YACE,MACA,QACA,UACA,QACA,aACA;AACA,UAAM,MAAM,UAAU,QAAQ,WAAW;AACzC,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB;AACvB,UAAM,SAAS,KAAK,QAAQ,MAAM;AAClC,UAAM,uBAAuB,KAAK,QAAQ,MAAM;AAEhD,SAAK,UAAU,YAAY,KAAK,MAAM,MAAM,sBAAsB;AAAA,MAChE,MAAM;AAAA,MACN,qBAAqB,KAAK,MAAM;AAAA,MAChC,kBAAkB,KAAK,MAAM;AAAA,MAC7B,cAAc,KAAK,MAAM;AAAA,MACzB,cAAc,KAAK,MAAM;AAAA,IAC3B,CAAC;AAED,WAAO;AAAA,MACL,iBAAiB;AAAA,QACf,cAAc,KAAK,MAAM;AAAA,QACzB,iBAAiB,qBAAqB,SAAS;AAAA,MACjD,CAAC;AAAA,IACH;AAEA,yBAAqB,MAAM;AAC3B,WAAO,OAAO,SAAS;AAAA,EACzB;AAAA,EAEA,UAAU;AAIR,SAAK,YAAY,KAAK,OAAO;AAK7B,SAAK,QAAQ;AAAA,MACX,gCAAgC;AAAA,QAC9B,WAAW,KAAK,MAAM;AAAA,QACtB,YAAY,KAAK,MAAM;AAAA,QACvB,cAAc,KAAK,MAAM;AAAA,MAC3B,CAAC;AAAA,IACH;AAQA,UAAM,qBAAqB,mBAAmB;AAAA,MAC5C,cAAc,KAAK,MAAM;AAAA,MACzB,MAAM,KAAK,MAAM;AAAA,MACjB,oBAAoB,GAAG,0BAA0B;AAAA,QAC/C,cAAc,KAAK,MAAM;AAAA,QACzB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,uBAAuB;AAAA,MACzB,CAAC,CAAC,GAAG,KAAK,uBAAuB,CAAC;AAAA,IACpC,CAAC;AAQD,UAAM,uBAAuB,kBAAkB;AAAA,MAC7C,cAAc,KAAK,MAAM;AAAA,MACzB,oBAAoB,GAAG,uBAAuB;AAAA,QAC5C,cAAc,KAAK,MAAM;AAAA,QACzB,aAAa,KAAK,MAAM;AAAA,QACxB,MAAM,KAAK,MAAM;AAAA,QACjB,kBAAkB;AAAA,MACpB,CAAC,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,kBAAkB;AAAA,IAChD,CAAC;AAMD,SAAK,QAAQ;AAAA,MACX,GAAG,oBAAoB,GAAG,KAAK,QAAQ,OAAO,GAAG,sBAAsB;AAAA,QACrE,WAAW,KAAK,MAAM;AAAA,QACtB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,cAAc,KAAK,MAAM;AAAA,QACzB,aAAa;AAAA,MACf,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AACF;;;AC5GA,SAAS,cAAc,KAAe;AACpC,SAAO,IAAI,IAAI,IAAI,CAAC,QAAQ,IAAI,GAAG,GAAG,EAAE,KAAK,IAAI,CAAC;AACpD;AAMO,SAAS,qBAAqB;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AACF,GAA0B;AACxB,MAAI,CAAC,wBAAwB;AAC3B,WAAO;AAAA,EACT;AAEA,QAAM,2BAA2B,cAAc,cAAc;AAC7D,SAAO,kBAAkB,YAAY,WAAW,YAAY,SAAS,wBAAwB;AAC/F;;;ACfO,IAAM,qBAAN,cAAiC,SAAS;AAAA,EAC/C;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YACE,MACA,QACA,UACA,QACA,aACA;AACA,UAAM,MAAM,UAAU,QAAQ,WAAW;AACzC,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,MAA2D;AACxE,QAAI,aAAa,KAAK,WAAW,IAAI,CAAC,UAAU,MAAM,SAAS;AAC/D,UAAM,mBAAmB,KAAK,OAAO,QAAQ,CAAC,UAAU,KAAK,oBAAoB,KAAK,CAAC;AACvF,WAAO,WAAW,OAAO,gBAAgB;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAoB,OAAkC;AACpD,WAAO,MAAM,WAAW,QAAQ,CAAC,cAAc;AAC7C,aAAO,KAAK,eAAe,UAAU,MAAM;AAAA,IAC7C,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB;AACvB,UAAM,SAAS,KAAK,QAAQ,MAAM;AAClC,UAAM,SAAS;AAAA,MACb,MAAM;AAAA,MACN,qBAAqB,KAAK,MAAM;AAAA,MAChC,kBAAkB,KAAK,MAAM;AAAA,MAC7B,cAAc,KAAK,MAAM;AAAA,MACzB,cAAc,KAAK,MAAM;AAAA,IAC3B;AAEA,SAAK,MAAM,WAAW,QAAQ,CAAC,UAAU,KAAK,UAAU,YAAY,OAAO,QAAQ,MAAM,CAAC;AAC1F,WAAO,OAAO,SAAS;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,uBAAuB;AACrB,UAAM,SAAS,KAAK,QAAQ,MAAM;AAClC,UAAM,SAAS;AAAA,MACb,MAAM;AAAA,MACN,qBAAqB,KAAK,MAAM;AAAA,MAChC,kBAAkB,KAAK,MAAM;AAAA,MAC7B,cAAc,KAAK,MAAM;AAAA,MACzB,cAAc,KAAK,MAAM;AAAA,IAC3B;AACA,SAAK,MAAM,OAAO,QAAQ,CAAC,UAAU,KAAK,oBAAoB,OAAO,QAAQ,MAAM,CAAC;AACpF,WAAO,OAAO,SAAS;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAoB,OAAwB,QAAwB,QAAwB;AAC1F,UAAM,WAAW,QAAQ,CAAC,WAAW,UAAU;AAC7C,YAAM,cAAc,OAAO,MAAM;AAEjC,gBAAU,OAAO,WAAW,QAAQ,CAAC,UAAU;AAC7C,aAAK,UAAU,YAAY,OAAO,aAAa,MAAM;AAAA,MACvD,CAAC;AAED,gBAAU,OAAO,OAAO,QAAQ,CAAC,UAAU;AACzC,aAAK,oBAAoB,OAAO,aAAa,MAAM;AAAA,MACrD,CAAC;AAED,aAAO;AAAA,QACL,uBAAuB;AAAA,UACrB,cAAc,KAAK,MAAM;AAAA,UACzB,aAAa,UAAU,IAAI,OAAO;AAAA,UAClC,oBAAoB,UAAU;AAAA,UAC9B,oBAAoB,YAAY,SAAS;AAAA,QAC3C,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAKD,QAAI,MAAM,0BAA0B,MAAM,WAAW,QAAQ;AAC3D,aAAO;AAAA,QACL,oBAAoB;AAAA,UAClB,cAAc,KAAK,MAAM;AAAA,UACzB,oBAAoB,MAAM;AAAA,QAC5B,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,UAAU;AAIR,SAAK,YAAY,KAAK,OAAO;AAK7B,SAAK,QAAQ;AAAA,MACX,gCAAgC;AAAA,QAC9B,WAAW,KAAK,MAAM;AAAA,QACtB,YAAY,KAAK,MAAM;AAAA,QACvB,cAAc,KAAK,MAAM;AAAA,MAC3B,CAAC;AAAA,IACH;AAQA,UAAM,qBAAqB,mBAAmB;AAAA,MAC5C,cAAc,KAAK,MAAM;AAAA,MACzB,MAAM,KAAK,MAAM;AAAA,MACjB,oBAAoB,GAAG,0BAA0B;AAAA,QAC/C,cAAc,KAAK,MAAM;AAAA,QACzB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,uBAAuB;AAAA,MACzB,CAAC,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,KAAK,uBAAuB,CAAC,GACvD,KAAK,QAAQ,OACf,GAAG,KAAK,qBAAqB,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,qBAAqB;AAAA,QAC3E,cAAc,KAAK,MAAM;AAAA,QACzB,wBAAwB,KAAK,MAAM;AAAA,QACnC,gBAAgB,KAAK,MAAM,yBAAyB,KAAK,eAAe,KAAK,KAAK,IAAI,CAAC;AAAA,MACzF,CAAC,CAAC;AAAA,IACJ,CAAC;AAQD,UAAM,kBAAkB,kBAAkB;AAAA,MACxC,cAAc,KAAK,MAAM;AAAA,MACzB,oBAAoB,GAAG,uBAAuB;AAAA,QAC5C,cAAc,KAAK,MAAM;AAAA,QACzB,aAAa,KAAK,MAAM;AAAA,QACxB,MAAM,KAAK,MAAM;AAAA,QACjB,kBAAkB;AAAA,MACpB,CAAC,CAAC,GAAG,kBAAkB;AAAA,IACzB,CAAC;AAMD,SAAK,QAAQ;AAAA,MACX,GAAG,eAAe,GAAG,KAAK,QAAQ,OAAO,GAAG,sBAAsB;AAAA,QAChE,cAAc,KAAK,MAAM;AAAA,QACzB,WAAW,KAAK,MAAM;AAAA,QACtB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,aAAa;AAAA,MACf,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AACF;;;AC9LO,SAAS,gBAAgB,QAAuC;AACrE,SAAO;AAAA,IACL,kBAAkB,OAAO;AAAA,IACzB,uBAAuB,OAAO;AAAA,IAC9B,qBAAqB;AAAA,IACrB,qBAAqB;AAAA,IACrB,cAAc;AAAA,IACd,cAAc,GAAG,OAAO,YAAY;AAAA,IACpC,iBAAiB;AAAA,IACjB,kBAAkB,OAAO;AAAA,IACzB,eAAe;AAAA,EACjB;AACF;;;ACAO,SAAS,uBAAuB;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AACF,GAAkB;AAChB,QAAM,wBAAwB,mBAC1B,SAAS,gBAAgB,MAAM,YAAY,WAAW,YAAY,MAClE,GAAG,YAAY;AAEnB,SAAO,OAAO,YAAY,iBAAiB,YAAY;AAAA,IACrD,gBAAgB,MAAM,qBAAqB;AAAA;AAE/C;;;ACdO,IAAM,sBAAN,cAAkC,SAAS;AAAA,EAChD;AAAA,EACA;AAAA,EAEA,YACE,MACA,QACA,UACA,QACA,aACA;AACA,UAAM,MAAM,UAAU,QAAQ,WAAW;AACzC,SAAK,QAAQ;AACb,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,UAAU;AAIR,SAAK,YAAY,KAAK,OAAO;AAK7B,SAAK,QAAQ;AAAA,MACX,gCAAgC;AAAA,QAC9B,WAAW,KAAK,MAAM;AAAA,QACtB,YAAY,KAAK,MAAM;AAAA,QACvB,cAAc,KAAK,MAAM;AAAA,MAC3B,CAAC;AAAA,IACH;AAKA,SAAK,QAAQ;AAAA,MACX,uBAAuB;AAAA,QACrB,cAAc,KAAK,MAAM;AAAA,QACzB,aAAa,KAAK,MAAM;AAAA,QACxB,MAAM,KAAK,MAAM;AAAA,QACjB,kBAAkB;AAAA,MACpB,CAAC;AAAA,IACH;AAKA,SAAK,QAAQ;AAAA,MACX,GAAG,uBAAuB;AAAA,QACxB,cAAc,KAAK,MAAM;AAAA,QACzB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,kBAAkB,KAAK,MAAM;AAAA,MAC/B,CAAC,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,sBAAsB;AAAA,QAChD,cAAc,KAAK,MAAM;AAAA,QACzB,WAAW,KAAK,MAAM;AAAA,QACtB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,kBAAkB,KAAK,MAAM;AAAA,QAC7B,aAAa;AAAA,MACf,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AACF;;;ACxEO,SAAS,iBAAiB,QAAuC;AACtE,QAAM,eAAe,OAAO,iBAAiB,KAAK,GAAG,OAAO,YAAY,OAAO;AAE/E,SAAO;AAAA,IACL,kBAAkB,OAAO;AAAA,IACzB,uBAAuB,GAAG,OAAO,YAAY;AAAA,IAC7C,qBAAqB,GAAG,OAAO,YAAY;AAAA,IAC3C,qBAAqB;AAAA,IACrB;AAAA,IACA,cAAc,GAAG,OAAO,YAAY;AAAA,IACpC,iBAAiB,GAAG,OAAO,YAAY,UAAU,OAAO,YAAY;AAAA,IACpE,kBAAkB,GAAG,OAAO,YAAY,QAAQ,OAAO,YAAY;AAAA,IACnE,eAAe;AAAA,EACjB;AACF;;;ACdO,SAAS,iBACd,MACA,QACe;AACf,QAAM,eACJ,OAAO,iBAAiB,KAAK,GAAG,OAAO,YAAY,IAAI,KAAK,SAAS,KAAK,KAAK;AAEjF,SAAO;AAAA,IACL,kBAAkB,OAAO;AAAA,IACzB,uBAAuB,GAAG,OAAO,YAAY;AAAA,IAC7C,qBAAqB,GAAG,KAAK,SAAS;AAAA,IACtC,qBAAqB;AAAA,IACrB;AAAA,IACA,cAAc,GAAG,OAAO,YAAY,SAAS,KAAK,SAAS;AAAA,IAC3D,iBAAiB,GAAG,OAAO,YAAY,UAAU,KAAK,SAAS;AAAA,IAC/D,kBAAkB,GAAG,OAAO,YAAY,QAAQ,KAAK,YAAY;AAAA,IACjE,eAAe;AAAA,EACjB;AACF;;;ACjBO,SAAS,eAAe;AAC7B,SAAO;AAAA;AAAA;AAGT;;;ACLO,SAAS,kBACd,MACA,kBACA,QACe;AACf,QAAM,eACJ,OAAO,iBAAiB,KAAK,GAAG,OAAO,YAAY,IAAI,KAAK,SAAS,KAAK,KAAK;AAEjF,SAAO;AAAA,IACL,kBAAkB,OAAO;AAAA,IACzB,uBAAuB,GAAG,OAAO,YAAY;AAAA,IAC7C,qBAAqB,IAAI,KAAK,SAAS;AAAA,IACvC,qBAAqB;AAAA,IACrB;AAAA,IACA,cAAc,GAAG,KAAK,YAAY,IAAI,gBAAgB;AAAA,IACtD,iBAAiB,GAAG,OAAO,YAAY,WAAW,KAAK,SAAS;AAAA,IAChE,kBAAkB,GAAG,OAAO,YAAY,SAAS,KAAK,YAAY;AAAA,IAClE,eAAe;AAAA,EACjB;AACF;;;ACnBO,SAAS,kBAAkB,QAAuC;AACvE,QAAM,eAAe,OAAO,iBAAiB,KAAK,GAAG,OAAO,YAAY,OAAO;AAE/E,SAAO;AAAA,IACL,kBAAkB,OAAO;AAAA,IACzB,uBAAuB,GAAG,OAAO,YAAY;AAAA,IAC7C,qBAAqB,GAAG,OAAO,YAAY;AAAA,IAC3C,qBAAqB;AAAA,IACrB;AAAA,IACA,cAAc,GAAG,OAAO,YAAY;AAAA,IACpC,iBAAiB,GAAG,OAAO,YAAY,UAAU,OAAO,YAAY;AAAA,IACpE,kBAAkB,GAAG,OAAO,YAAY,QAAQ,OAAO,YAAY;AAAA,IACnE,eAAe;AAAA,EACjB;AACF;;;ACZO,SAAS,sBAAsB,SAAiD;AACrF,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA,IAKL,QAAQ,4BAA4B,wCAAwC,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiElF;;;ACrEO,SAAS,0BACd,UACA;AACA,SAAO,qBAAqB,SAAS,QAAQ;AAAA,yBACtB,SAAS,MAAM;AAAA,wBAChB,SAAS,KAAK;AACtC;;;ACiBA,IAAM,gBAAgB,OAAO,eAAe,iBAAkB;AAAC,CAAC,EAAE;AAM3D,IAAM,WAAN,MAAe;AAAA;AAAA;AAAA;AAAA;AAAA,EAKpB,mBAA2B;AAAA;AAAA;AAAA;AAAA,EAK3B;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA,UAA0B,IAAI,eAAe;AAAA,EAE7C,YAAY,UAAoB,SAA2B;AACzD,SAAK,YAAY;AACjB,SAAK,WAAW,WAAW,EAAE,2BAA2B,MAAM;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAoB;AAClB,SAAK,QAAQ;AAAA,MACX,0BAA0B;AAAA,QACxB,UAAU;AAAA,QACV,QAAQ;AAAA,QACR,OAAO;AAAA,QACP,GAAG,KAAK,SAAS;AAAA,MACnB,CAAC;AAAA,IACH;AACA,SAAK,QAAQ,eAAe,sBAAsB,KAAK,QAAQ,CAAC;AAChE,SAAK,QAAQ,eAAe,UAAU;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB;AAChB,SAAK,QAAQ,eAAe,aAAa,CAAC;AAC1C,SAAK,QAAQ,eAAe,aAAa;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB;AACd,SAAK,YAAY,KAAK,UAAU,QAAQ,KAAK,SAAS;AAAA,MACpD,MAAM;AAAA,MACN,cAAc;AAAA,MACd,kBAAkB;AAAA,MAClB,qBAAqB;AAAA,MACrB,cAAc;AAAA,IAChB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,mBAMgB;AACd,WAAO,IAAI;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,QAAQ,SAAS;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,MAAqB,QAAwB;AAC1D,YAAQ,OAAO,MAAM;AAAA,MACnB,KAAK;AACH,eAAO,iBAAiB,MAAM;AAAA,MAChC,KAAK;AACH,eAAO,gBAAgB,MAAM;AAAA,MAC/B,KAAK;AACH,eAAO,kBAAkB,MAAM,KAAK,kBAAkB,MAAM;AAAA,MAC9D,KAAK;AACH,eAAO,iBAAiB,MAAM,MAAM;AAAA,MACtC,KAAK;AACH,eAAO,kBAAkB,MAAM;AAAA,IACnC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YACE,MACA,QACA,QACA,aACA;AACA,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AACH,eAAO,IAAI,oBAAoB,MAAM,QAAQ,MAAM,QAAQ,WAAW,EAAE,QAAQ;AAAA,MAClF,KAAK;AACH,eAAO,IAAI,kBAAkB,MAAM,QAAQ,MAAM,QAAQ,WAAW,EAAE,QAAQ;AAAA,MAChF,KAAK;AACH,eAAO,IAAI,mBAAmB,MAAM,QAAQ,MAAM,QAAQ,WAAW,EAAE,QAAQ;AAAA,MACjF,KAAK;AACH,eAAO,IAAI,mBAAmB,MAAM,QAAQ,MAAM,QAAQ,WAAW,EAAE,QAAQ;AAAA,MACjF,KAAK;AACH,eAAO,IAAI,kBAAkB,MAAM,QAAQ,MAAM,QAAQ,WAAW,EAAE,QAAQ;AAAA,MAChF,KAAK;AACH,eAAO,IAAI,kBAAkB,MAAM,QAAQ,MAAM,QAAQ,WAAW,EAAE,QAAQ;AAAA,IAClF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AACR,SAAK,kBAAkB;AACvB,SAAK,cAAc;AACnB,SAAK,gBAAgB;AAErB,UAAM,iBAAiB,KAAK,iBAAiB;AAE7C,SAAK,mBAAmB;AACxB,SAAK,QAAQ,MAAM;AAEnB,WAAO;AAAA,EACT;AACF;;;ACrKO,SAAS,cAAyB;AACvC,MAAI,UAAU;AACd,QAAM,OAAa,CAAC;AAEpB,SAAO;AAAA,IACL,SAAS;AACP,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,OAAwC;AAC5C;AACA,YAAM,MAAM,SAAS,OAAO;AAC5B,WAAK,GAAG,IAAI;AACZ,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA,IAKA,gBAAgB,YAA2C;AACzD,aAAO,KAAK,MAAM,UAAU;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA,IAKA,YAAY,IAA4B;AACtC,aAAO,KAAK,MAAM,EAAE;AAAA,IACtB;AAAA;AAAA;AAAA;AAAA,IAKA,iBAAiB,IAA0C;AACzD,aAAO,KAAK,MAAM,EAAE;AAAA,IACtB;AAAA;AAAA;AAAA;AAAA,IAKA,iBAAiB,IAAuC;AACtD,aAAO,KAAK,MAAM,EAAE;AAAA,IACtB;AAAA,EACF;AACF;","names":[]}