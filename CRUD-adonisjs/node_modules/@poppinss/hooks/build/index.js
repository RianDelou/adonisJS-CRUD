// src/runner.ts
import { debuglog } from "node:util";
var debug = debuglog("poppinss:hooks");
var Runner = class {
  constructor(action, hookHandlers) {
    this.action = action;
    this.#hookHandlers = hookHandlers || /* @__PURE__ */ new Set();
  }
  /**
   * A collection of registered hook handlers
   */
  #hookHandlers;
  /**
   * Cleanup handlers should always be an array of functions. Using a set will
   * discard duplicates and it is very much possible for two hooks to return
   * a shared cleanup handler.
   */
  #cleanupHandlers = [];
  /**
   * State to perform the cleanup
   */
  #state = "idle";
  /**
   * A collection of handlers to ignore when executed them
   */
  #handlersToIgnore = [];
  /**
   * Whether or not to skip all the hooks
   */
  #skipAllHooks = false;
  /**
   * Find if cleanup is pending or not
   */
  get isCleanupPending() {
    return this.#state === "cleanup_pending";
  }
  /**
   * Filter to check if we should run the handler
   */
  #filter(handlerName) {
    return !this.#handlersToIgnore.includes(handlerName);
  }
  /**
   * Ignore specific or all hook handlers. Calling this
   * method multiple times will result in overwriting
   * the existing state.
   */
  without(handlersToIgnore) {
    if (!handlersToIgnore) {
      debug("skipping all hooks");
      this.#skipAllHooks = true;
    } else {
      this.#skipAllHooks = false;
      debug("skipping %O hooks", handlersToIgnore);
      this.#handlersToIgnore = handlersToIgnore;
    }
    return this;
  }
  /**
   * Executing hooks
   */
  async #exec(reverse, data) {
    if (this.#state !== "idle") {
      return;
    }
    this.#state = "cleanup_pending";
    if (this.#skipAllHooks) {
      return;
    }
    debug("running hooks");
    const handlers = reverse ? Array.from(this.#hookHandlers).reverse() : this.#hookHandlers;
    for (let handler of handlers) {
      if (this.#filter(handler.name)) {
        if (handler.name) {
          debug("running hook %s", handler.name);
        }
        const result = await (typeof handler === "function" ? handler(...data) : handler.handle(this.action, ...data));
        if (typeof result === "function") {
          if (handler.name) {
            debug("cleanup scheduled by %s hook", handler.name);
          }
          this.#cleanupHandlers.push(result);
        }
      }
    }
  }
  /**
   * Execute handlers
   */
  async run(...data) {
    return this.#exec(false, data);
  }
  /**
   * Execute handlers in reverse order
   */
  async runReverse(...data) {
    return this.#exec(true, data);
  }
  /**
   * Execute cleanup actions
   */
  async cleanup(...data) {
    if (!this.isCleanupPending) {
      return;
    }
    this.#state = "cleanup_initiated";
    debug("performing cleanup");
    let startIndex = this.#cleanupHandlers.length;
    while (startIndex--) {
      await this.#cleanupHandlers[startIndex](...data);
    }
    this.#state = "cleanup_completed";
    this.#cleanupHandlers = [];
  }
};

// src/hooks.ts
var Hooks = class {
  /**
   * A collection of registered hooks
   */
  #hooks = /* @__PURE__ */ new Map();
  /**
   * Get access to all the registered hooks. The return value is
   * a map of the event name and a set of handlers.
   */
  all() {
    return this.#hooks;
  }
  /**
   * Find if a handler for a given event exists.
   */
  has(event, handler) {
    const handlers = this.#hooks.get(event);
    if (!handlers) {
      return false;
    }
    return handlers.has(handler);
  }
  /**
   * Add a hook handler for a given event. Adding the same handler twice will
   * result in a noop.
   */
  add(event, handler) {
    const handlers = this.#hooks.get(event);
    if (!handlers) {
      this.#hooks.set(event, /* @__PURE__ */ new Set());
    }
    this.#hooks.get(event).add(handler);
    return this;
  }
  /**
   * Remove hook handler for a given event.
   */
  remove(event, handler) {
    const handlers = this.#hooks.get(event);
    if (!handlers) {
      return false;
    }
    return handlers.delete(handler);
  }
  /**
   * Clear all the hooks for a specific event or all the
   * events.
   */
  clear(event) {
    if (!event) {
      this.#hooks.clear();
      return;
    }
    this.#hooks.delete(event);
  }
  /**
   * Merge hooks from an existing hooks instance.
   */
  merge(hooks) {
    hooks.all().forEach((actionHooks, action) => {
      actionHooks.forEach((handler) => {
        this.add(action, handler);
      });
    });
  }
  /**
   * Returns an instance of the runner to run hooks
   */
  runner(action) {
    return new Runner(action, this.#hooks.get(action));
  }
};
export {
  Hooks as default
};
//# sourceMappingURL=index.js.map