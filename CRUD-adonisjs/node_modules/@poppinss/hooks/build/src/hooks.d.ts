import { Runner } from './runner.js';
import { HookHandler, HookHandlerProvider } from './types.js';
/**
 * Quite simple implementation register lifecycle hooks around specific events.
 *
 * ```ts
 * const hooks = new Hooks()
 *
 * hooks.add('saving', function hashPassword(entity) {
 * })
 * ```
 */
export declare class Hooks<Events extends Record<string, [any[], any[]]>> {
    #private;
    /**
     * Get access to all the registered hooks. The return value is
     * a map of the event name and a set of handlers.
     */
    all(): { [Event in keyof Events]: Map<Event, Set<HookHandler<Events[Event][0], Events[Event][1]> | HookHandlerProvider<Events[Event][0], Events[Event][1]>>>; }[keyof Events];
    /**
     * Find if a handler for a given event exists.
     */
    has<Event extends keyof Events>(event: Event, handler: HookHandler<Events[Event][0], Events[Event][1]> | HookHandlerProvider<Events[Event][0], Events[Event][1]>): boolean;
    /**
     * Add a hook handler for a given event. Adding the same handler twice will
     * result in a noop.
     */
    add<Event extends keyof Events>(event: Event, handler: HookHandler<Events[Event][0], Events[Event][1]> | HookHandlerProvider<Events[Event][0], Events[Event][1]>): this;
    /**
     * Remove hook handler for a given event.
     */
    remove<Event extends keyof Events>(event: Event, handler: HookHandler<Events[Event][0], Events[Event][1]> | HookHandlerProvider<Events[Event][0], Events[Event][1]>): boolean;
    /**
     * Clear all the hooks for a specific event or all the
     * events.
     */
    clear(event?: keyof Events): void;
    /**
     * Merge hooks from an existing hooks instance.
     */
    merge(hooks: Hooks<Events>): void;
    /**
     * Returns an instance of the runner to run hooks
     */
    runner<Event extends Extract<keyof Events, string>>(action: Event): Runner<Events[Event][0], Events[Event][1]>;
}
