{"version":3,"sources":["../src/runner.ts","../src/hooks.ts"],"sourcesContent":["/*\n * @poppinss/hooks\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { debuglog } from 'node:util'\nimport { HookHandler, CleanupHandler, HookHandlerProvider } from './types.js'\n\nconst debug = debuglog('poppinss:hooks')\n\n/**\n * Runner allows running a set of specific hook handlers for a given\n * event. You can grab the instance of the runner using the \"hook.runner\" method.\n *\n * ```ts\n * const hooks = new Hooks()\n *\n * await hooks.runner('saving').run()\n * ```\n */\nexport class Runner<HookArgs extends any[], CleanUpArgs extends any[]> {\n  /**\n   * A collection of registered hook handlers\n   */\n  #hookHandlers: Set<\n    HookHandler<HookArgs, CleanUpArgs> | HookHandlerProvider<HookArgs, CleanUpArgs>\n  >\n\n  /**\n   * Cleanup handlers should always be an array of functions. Using a set will\n   * discard duplicates and it is very much possible for two hooks to return\n   * a shared cleanup handler.\n   */\n  #cleanupHandlers: CleanupHandler<CleanUpArgs>[] = []\n\n  /**\n   * State to perform the cleanup\n   */\n  #state: 'idle' | 'cleanup_pending' | 'cleanup_initiated' | 'cleanup_completed' = 'idle'\n\n  /**\n   * A collection of handlers to ignore when executed them\n   */\n  #handlersToIgnore: string[] = []\n\n  /**\n   * Whether or not to skip all the hooks\n   */\n  #skipAllHooks: boolean = false\n\n  /**\n   * Find if cleanup is pending or not\n   */\n  get isCleanupPending() {\n    return this.#state === 'cleanup_pending'\n  }\n\n  constructor(\n    public action: string,\n    hookHandlers?: Set<\n      HookHandler<HookArgs, CleanUpArgs> | HookHandlerProvider<HookArgs, CleanUpArgs>\n    >\n  ) {\n    this.#hookHandlers = hookHandlers || new Set()\n  }\n\n  /**\n   * Filter to check if we should run the handler\n   */\n  #filter(handlerName: string): boolean {\n    return !this.#handlersToIgnore.includes(handlerName)\n  }\n\n  /**\n   * Ignore specific or all hook handlers. Calling this\n   * method multiple times will result in overwriting\n   * the existing state.\n   */\n  without(handlersToIgnore?: string[]): this {\n    if (!handlersToIgnore) {\n      debug('skipping all hooks')\n      this.#skipAllHooks = true\n    } else {\n      this.#skipAllHooks = false\n      debug('skipping %O hooks', handlersToIgnore)\n      this.#handlersToIgnore = handlersToIgnore\n    }\n\n    return this\n  }\n\n  /**\n   * Executing hooks\n   */\n  async #exec(reverse: boolean, data: HookArgs) {\n    if (this.#state !== 'idle') {\n      return\n    }\n\n    this.#state = 'cleanup_pending'\n    if (this.#skipAllHooks) {\n      return\n    }\n\n    debug('running hooks')\n\n    const handlers = reverse ? Array.from(this.#hookHandlers).reverse() : this.#hookHandlers\n    for (let handler of handlers) {\n      if (this.#filter(handler.name)) {\n        if (handler.name) {\n          debug('running hook %s', handler.name)\n        }\n\n        const result = await (typeof handler === 'function'\n          ? handler(...data)\n          : handler.handle(this.action, ...data))\n\n        if (typeof result === 'function') {\n          if (handler.name) {\n            debug('cleanup scheduled by %s hook', handler.name)\n          }\n          this.#cleanupHandlers.push(result)\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute handlers\n   */\n  async run(...data: HookArgs): Promise<void> {\n    return this.#exec(false, data)\n  }\n\n  /**\n   * Execute handlers in reverse order\n   */\n  async runReverse(...data: HookArgs): Promise<void> {\n    return this.#exec(true, data)\n  }\n\n  /**\n   * Execute cleanup actions\n   */\n  async cleanup(...data: CleanUpArgs) {\n    if (!this.isCleanupPending) {\n      return\n    }\n\n    this.#state = 'cleanup_initiated'\n    debug('performing cleanup')\n\n    let startIndex = this.#cleanupHandlers.length\n    while (startIndex--) {\n      await this.#cleanupHandlers[startIndex](...data)\n    }\n\n    this.#state = 'cleanup_completed'\n    this.#cleanupHandlers = []\n  }\n}\n","/*\n * @poppinss/hooks\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Runner } from './runner.js'\nimport { HookHandler, HookHandlerProvider } from './types.js'\n\n/**\n * Quite simple implementation register lifecycle hooks around specific events.\n *\n * ```ts\n * const hooks = new Hooks()\n *\n * hooks.add('saving', function hashPassword(entity) {\n * })\n * ```\n */\nexport class Hooks<Events extends Record<string, [any[], any[]]>> {\n  /**\n   * A collection of registered hooks\n   */\n  #hooks: {\n    [Event in keyof Events]: Map<\n      Event,\n      Set<\n        | HookHandler<Events[Event][0], Events[Event][1]>\n        | HookHandlerProvider<Events[Event][0], Events[Event][1]>\n      >\n    >\n  }[keyof Events] = new Map()\n\n  /**\n   * Get access to all the registered hooks. The return value is\n   * a map of the event name and a set of handlers.\n   */\n  all() {\n    return this.#hooks\n  }\n\n  /**\n   * Find if a handler for a given event exists.\n   */\n  has<Event extends keyof Events>(\n    event: Event,\n    handler:\n      | HookHandler<Events[Event][0], Events[Event][1]>\n      | HookHandlerProvider<Events[Event][0], Events[Event][1]>\n  ): boolean {\n    const handlers = this.#hooks.get(event)\n    if (!handlers) {\n      return false\n    }\n\n    return handlers.has(handler)\n  }\n\n  /**\n   * Add a hook handler for a given event. Adding the same handler twice will\n   * result in a noop.\n   */\n  add<Event extends keyof Events>(\n    event: Event,\n    handler:\n      | HookHandler<Events[Event][0], Events[Event][1]>\n      | HookHandlerProvider<Events[Event][0], Events[Event][1]>\n  ): this {\n    const handlers = this.#hooks.get(event)\n\n    /**\n     * Instantiate handlers\n     */\n    if (!handlers) {\n      this.#hooks.set(event, new Set())\n    }\n\n    this.#hooks.get(event)!.add(handler)\n    return this\n  }\n\n  /**\n   * Remove hook handler for a given event.\n   */\n  remove<Event extends keyof Events>(\n    event: Event,\n    handler:\n      | HookHandler<Events[Event][0], Events[Event][1]>\n      | HookHandlerProvider<Events[Event][0], Events[Event][1]>\n  ): boolean {\n    const handlers = this.#hooks.get(event)\n    if (!handlers) {\n      return false\n    }\n\n    return handlers.delete(handler)\n  }\n\n  /**\n   * Clear all the hooks for a specific event or all the\n   * events.\n   */\n  clear(event?: keyof Events): void {\n    if (!event) {\n      this.#hooks.clear()\n      return\n    }\n\n    this.#hooks.delete(event)\n  }\n\n  /**\n   * Merge hooks from an existing hooks instance.\n   */\n  merge(hooks: Hooks<Events>) {\n    hooks.all().forEach((actionHooks, action) => {\n      actionHooks.forEach((handler) => {\n        this.add(action, handler)\n      })\n    })\n  }\n\n  /**\n   * Returns an instance of the runner to run hooks\n   */\n  runner<Event extends Extract<keyof Events, string>>(\n    action: Event\n  ): Runner<Events[Event][0], Events[Event][1]> {\n    return new Runner(action, this.#hooks.get(action))\n  }\n}\n"],"mappings":"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","names":[]}