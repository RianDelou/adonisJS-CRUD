var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/enquirer.ts
import enq from "enquirer";

// src/base.ts
import { AssertionError as AssertionError2 } from "node:assert";
import { ObjectBuilder } from "@poppinss/utils";

// src/colors.ts
import useColors from "@poppinss/colors";
var colors = useColors.ansi();

// src/mocked_prompt.ts
import { inspect } from "node:util";
import { AssertionError } from "node:assert";
var MockedPrompt = class {
  /**
   * The final answer to reply with
   */
  #answer;
  /**
   * The selected index for the select prompt
   */
  #choiceSelection;
  /**
   * Selected indexes for the multi-select prompt
   */
  #multiChoiceSelection;
  /**
   * Expected assertions
   */
  #assertions = [];
  /**
   * Set the answer without overriding the existing one
   */
  #setAnswer(answer) {
    if (this.#answer === void 0) {
      this.#answer = answer;
    }
  }
  /**
   * Choose the default option when no explicit selection was made.
   *
   * - Choose the initial value
   * - Or, select the first option, if no initial value exists
   */
  #setSelectDefaults(options) {
    const defaultAnswer = options.initial !== void 0 ? options.initial : 0;
    if (typeof defaultAnswer === "number") {
      if (this.#choiceSelection === void 0) {
        this.#choiceSelection = defaultAnswer;
      }
      return;
    }
    if (defaultAnswer !== void 0) {
      this.#setAnswer(defaultAnswer);
    }
  }
  /**
   * Choose the default option when no explicit selection was made.
   *
   * - Choose the initial value
   */
  #setMultiSelectDefaults(options) {
    this.#setAnswer(options.initial);
  }
  /**
   * Select the default answer for the toggle prompt when no
   * explicit selection was made.
   *
   * - Choose the initial value (if exists)
   * - Set answer to false
   */
  #setToggleDefaults(options) {
    this.#setAnswer(options.initial !== void 0 ? options.initial : false);
  }
  /**
   * Select the default answer for the confirmation prompt, when
   * no explicit selection was made
   *
   * - Choose the initial value (if exists)
   * - Set answer to false
   */
  #setConfirmationDefaults(options) {
    this.#setAnswer(options.initial !== void 0 ? options.initial : false);
  }
  /**
   * Select the default answer for the input and password prompts, when
   * no explicit selection was made
   *
   * - Choose the initial value (if exists)
   */
  #setTextDefaults(options) {
    this.#setAnswer(options.initial);
  }
  /**
   * Conditionals to find the prompt type
   */
  #isToggle(options) {
    return options.type === "toggle";
  }
  #isConfirmation(options) {
    return options.type === "confirm";
  }
  #isSelect(options) {
    return options.type === "select" && options.choices || options.type === "autocomplete" && !options.multiple && options.choices;
  }
  #isMultiSelect(options) {
    return options.type === "multiselect" && options.choices || options.type === "autocomplete" && options.multiple && options.choices;
  }
  #isText(options) {
    return options.type === "input" || options.type === "password" || options.type === "list";
  }
  /**
   * Run assertions on the final answer
   */
  async #assert(options) {
    const state = {
      message: options.message,
      type: options.type,
      name: options.name,
      value: ""
    };
    if (!options.validate && this.#assertions.length) {
      throw this.#assertions[0].error;
    }
    for (let assertion of this.#assertions) {
      const result = await options.validate(assertion.value, state);
      if (!assertion.expectsError) {
        if (result !== true) {
          throw assertion.error;
        }
      } else {
        if (result === true) {
          throw assertion.error;
        }
        if (typeof assertion.expectedErrorMessage === "string" && result !== assertion.expectedErrorMessage) {
          assertion.error.actual = result;
          throw assertion.error;
        }
        if (assertion.expectedErrorMessage instanceof RegExp && !assertion.expectedErrorMessage.test(result)) {
          throw assertion.error;
        }
      }
    }
  }
  /**
   * Format user input. Inside CLI, the method is called
   * as the user types
   */
  #formatInput(input, options) {
    if (options.type === "list") {
      return input.split(options.sep);
    }
    return input;
  }
  /**
   * Transform the final result
   */
  async #transformResult(result, options) {
    if (typeof options.result === "function") {
      return options.result(result);
    }
    return result;
  }
  /**
   * Convert the user selection choice to answer
   */
  #convertChoiceToAnswer(options) {
    if (this.#answer !== void 0) {
      return;
    }
    const answer = options.choices[this.#choiceSelection];
    this.#setAnswer(typeof answer === "string" ? answer : answer?.name);
  }
  /**
   * Convert the user multiple selection choice to answer
   */
  #convertMultipleChoicesToAnswer(options) {
    if (this.#answer !== void 0) {
      if (!Array.isArray(this.#answer)) {
        this.#answer = [this.#answer];
      }
      return;
    }
    if (!this.#multiChoiceSelection) {
      this.#multiChoiceSelection = this.#choiceSelection !== void 0 ? [this.#choiceSelection] : [];
    }
    const answers = this.#multiChoiceSelection.map((index) => {
      const answer = options.choices[index];
      return typeof answer === "string" ? answer : answer?.name;
    });
    this.#setAnswer(answers);
  }
  constructor() {
  }
  /**
   * Reply to prompt with a given answer
   */
  replyWith(answer) {
    this.#answer = answer;
    return this;
  }
  /**
   * Accept the confirmation or the toggle prompt
   */
  accept() {
    return this.replyWith(true);
  }
  /**
   * Reject the confirmation or the toggle prompt
   */
  reject() {
    return this.replyWith(false);
  }
  /**
   * Choose a select option by index. The index starts with zero
   */
  chooseOption(index) {
    this.#choiceSelection = index;
    return this;
  }
  /**
   * Choose multiple options by indexes. The index starts with zero
   */
  chooseOptions(indexes) {
    this.#multiChoiceSelection = indexes;
    return this;
  }
  /**
   * Expect the given value to fail the prompt validation
   */
  assertFails(value, message) {
    if (!message) {
      this.#assertions.push({
        value,
        expectsError: true,
        expectedErrorMessage: message,
        error: new AssertionError({
          message: "Expected prompt validation to fail",
          stackStartFn: this.assertFails
        })
      });
      return this;
    }
    if (typeof message === "string") {
      const error = new AssertionError({
        message: `Expected prompt validation message to equal ${inspect(message)}`,
        expected: message,
        operator: "strictEqual",
        stackStartFn: this.assertFails
      });
      Object.defineProperty(error, "showDiff", { value: true });
      this.#assertions.push({
        value,
        expectsError: true,
        expectedErrorMessage: message,
        error
      });
      return this;
    }
    this.#assertions.push({
      value,
      expectsError: true,
      expectedErrorMessage: message,
      error: new AssertionError({
        message: `Expected prompt validation message to match ${inspect(message)}`,
        expected: message
      })
    });
    return this;
  }
  /**
   * Expect the given value to pass the prompt validation
   */
  assertPasses(value) {
    const error = new AssertionError({
      message: "Expected assertion to pass, instead it failed"
    });
    this.#assertions.push({
      value,
      expectsError: false,
      error
    });
    return this;
  }
  /**
   * Handle the prompt
   */
  async handle(options) {
    if (this.#isSelect(options)) {
      this.#setSelectDefaults(options);
      this.#convertChoiceToAnswer(options);
    } else if (this.#isMultiSelect(options)) {
      this.#setMultiSelectDefaults(options);
      this.#convertMultipleChoicesToAnswer(options);
    } else if (this.#isToggle(options)) {
      this.#setToggleDefaults(options);
    } else if (this.#isConfirmation(options)) {
      this.#setConfirmationDefaults(options);
    } else if (this.#isText(options)) {
      this.#setTextDefaults(options);
    }
    this.#answer = this.#formatInput(this.#answer, options);
    await this.#assert(options);
    return this.#transformResult(this.#answer, options);
  }
};

// src/icons.ts
var icons = process.platform === "win32" && !process.env.WT_SESSION ? { pointer: ">" } : { pointer: "\u276F" };

// src/prompt_options.ts
var promptStyles = {
  danger: (value) => colors.red(value),
  submitted: (value) => colors.cyan(value)
};
var promptPrefix = colors.dim(icons.pointer);
var promptHiglight = (value) => colors.yellow(value);

// src/base.ts
var BasePrompt = class {
  traps = {
    prompts: /* @__PURE__ */ new Map(),
    verify() {
      this.prompts.forEach((entry) => {
        throw entry.triggerError;
      });
    }
  };
  /**
   * Handle the prompt. The mocked prompts are given preference if one exists
   */
  #handlePrompt(options) {
    let mockedPrompt;
    if (this.traps.prompts.has(options.name)) {
      mockedPrompt = this.traps.prompts.get(options.name).prompt;
      this.traps.prompts.delete(options.name);
    } else if (this.traps.prompts.has(options.message)) {
      mockedPrompt = this.traps.prompts.get(options.message).prompt;
      this.traps.prompts.delete(options.message);
    }
    if (mockedPrompt) {
      return mockedPrompt.handle(options);
    }
    return this.prompt(options);
  }
  /**
   * Prompts for text input
   */
  async ask(title, options) {
    options = options || {};
    const builder = new ObjectBuilder({});
    builder.add("type", "input");
    builder.add("name", options.name || "prompt");
    builder.add("message", title);
    builder.add("hint", options.hint);
    builder.add("initial", options.default);
    builder.add("result", options.result);
    builder.add("format", options.format);
    builder.add("validate", options.validate);
    builder.add("prefix", promptPrefix);
    builder.add("styles", promptStyles);
    return this.#handlePrompt(builder.toObject());
  }
  /**
   * Prompt to accept a list of comma separated values
   */
  async list(title, options) {
    options = options || {};
    const builder = new ObjectBuilder({});
    builder.add("type", "list");
    builder.add("name", options.name || "prompt");
    builder.add("sep", options.seperator || ",");
    builder.add("name", options.name);
    builder.add("message", title);
    builder.add("hint", options.hint);
    builder.add("initial", options.default);
    builder.add("result", options.result);
    builder.add("format", options.format);
    builder.add("validate", options.validate);
    builder.add("prefix", promptPrefix);
    builder.add("styles", promptStyles);
    return this.#handlePrompt(builder.toObject());
  }
  /**
   * Prompts for text input but masks the output (for password)
   */
  async secure(title, options) {
    options = options || {};
    const builder = new ObjectBuilder({});
    builder.add("type", "password");
    builder.add("name", options.name || "prompt");
    builder.add("message", title);
    builder.add("initial", options.default);
    builder.add("result", options.result);
    builder.add("format", options.format);
    builder.add("validate", options.validate);
    builder.add("prefix", promptPrefix);
    builder.add("styles", promptStyles);
    return this.#handlePrompt(builder.toObject());
  }
  /**
   * Asks for `Y/n`
   */
  async confirm(title, options) {
    options = options || {};
    const builder = new ObjectBuilder({});
    builder.add("type", "confirm");
    builder.add("name", options.name || "prompt");
    builder.add("message", title);
    builder.add("hint", options.hint);
    builder.add("initial", options.default);
    builder.add("result", options.result);
    builder.add("format", options.format);
    builder.add("validate", options.validate);
    builder.add("prefix", promptPrefix);
    builder.add("styles", promptStyles);
    return this.#handlePrompt(builder.toObject());
  }
  /**
   * Similar to [[this.confirm]] but with custom names for the `Y/n` options
   */
  async toggle(title, choices, options) {
    options = options || {};
    const builder = new ObjectBuilder({});
    builder.add("type", "toggle");
    builder.add("name", options.name || "prompt");
    builder.add("message", title);
    builder.add("hint", options.hint);
    builder.add("initial", options.default);
    builder.add("result", options.result);
    builder.add("format", options.format);
    builder.add("validate", options.validate);
    builder.add("enabled", choices[0]);
    builder.add("disabled", choices[1]);
    builder.add("prefix", promptPrefix);
    builder.add("styles", promptStyles);
    return this.#handlePrompt(builder.toObject());
  }
  /**
   * Prompt to select a value from the list of options
   */
  async choice(title, choices, options) {
    options = options || {};
    const builder = new ObjectBuilder({});
    builder.add("type", "select");
    builder.add("name", options.name || "prompt");
    builder.add("message", title);
    builder.add("initial", options.default);
    builder.add("hint", options.hint || "Press <ENTER> to select");
    builder.add("result", options.result);
    builder.add("format", options.format);
    builder.add("validate", options.validate);
    builder.add("prefix", promptPrefix);
    builder.add("styles", promptStyles);
    builder.add(
      "choices",
      choices.map((choice) => {
        if (typeof choice === "string") {
          return { name: choice, message: choice, value: choice };
        }
        return choice;
      })
    );
    return this.#handlePrompt(builder.toObject());
  }
  /**
   * Prompt to select multiple values from the list of options
   */
  async multiple(title, choices, options) {
    options = options || {};
    const builder = new ObjectBuilder({});
    builder.add("type", "multiselect");
    builder.add("name", options.name || "prompt");
    builder.add("message", title);
    builder.add("initial", options.default);
    builder.add("result", options.result);
    builder.add("format", options.format);
    builder.add("hint", options.hint || "Press <SPACE> to select");
    builder.add("validate", options.validate);
    builder.add("prefix", promptPrefix);
    builder.add("styles", promptStyles);
    builder.add("indicator", (state, choice) => {
      if (choice.enabled) {
        return colors.cyan(state.symbols.radio.on);
      }
      return colors.dim(state.symbols.radio.off);
    });
    builder.add(
      "choices",
      choices.map((choice) => {
        if (typeof choice === "string") {
          return { name: choice, message: choice, value: choice };
        }
        return choice;
      })
    );
    return this.#handlePrompt(builder.toObject());
  }
  /**
   * Prompt to select one or multiple values from the list of searchable
   * options.
   */
  async autocomplete(title, choices, options) {
    options = options || {};
    const builder = new ObjectBuilder({});
    builder.add("type", "autocomplete");
    builder.add("name", options.name || "prompt");
    builder.add("message", title);
    builder.add("initial", options.default);
    builder.add("multiple", options.multiple);
    builder.add("result", options.result);
    builder.add(
      "hint",
      options.hint || options.multiple ? "Press <SPACE> to select" : "Press <ENTER> to select"
    );
    builder.add("format", options.format);
    builder.add("limit", options.limit);
    builder.add("validate", options.validate);
    builder.add("footer", options.footer);
    builder.add("choices", choices);
    builder.add("prefix", promptPrefix);
    builder.add("highlight", promptHiglight);
    builder.add("styles", promptStyles);
    return this.#handlePrompt(builder.toObject());
  }
  /**
   * Trap a prompt by its message or unique name
   */
  trap(message) {
    const triggerError = new AssertionError2({
      message: `Expected prompt "${message}" to get triggered`
    });
    const mockedPrompt = new MockedPrompt();
    this.traps.prompts.set(message, { prompt: mockedPrompt, triggerError });
    return mockedPrompt;
  }
};

// src/errors.ts
var errors_exports = {};
__export(errors_exports, {
  E_PROMPT_CANCELLED: () => E_PROMPT_CANCELLED
});
import { createError } from "@poppinss/utils";
var E_PROMPT_CANCELLED = createError("Prompt cancelled", "E_PROMPT_CANCELLED", 500);

// src/enquirer.ts
var enquirer = enq;
var Prompt = class extends BasePrompt {
  async prompt(options) {
    let cancelled = false;
    options = Object.assign(
      {
        onCancel() {
          cancelled = true;
        }
      },
      options
    );
    try {
      const output = await enquirer.prompt(options);
      return output[options.name];
    } catch (error) {
      if (cancelled) {
        throw new E_PROMPT_CANCELLED();
      }
      throw error;
    }
  }
};
export {
  Prompt,
  errors_exports as errors
};
//# sourceMappingURL=index.js.map