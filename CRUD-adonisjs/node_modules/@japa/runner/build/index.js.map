{"version":3,"sources":["../index.ts","../src/plugins/retry.ts","../src/exceptions_manager.ts"],"sourcesContent":["/*\n * @japa/runner\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { fileURLToPath } from 'node:url'\nimport { ErrorsPrinter } from '@japa/errors-printer'\nimport type { TestExecutor } from '@japa/core/types'\n\nimport debug from './src/debug.js'\nimport validator from './src/validator.js'\nimport { Planner } from './src/planner.js'\nimport { GlobalHooks } from './src/hooks.js'\nimport { CliParser } from './src/cli_parser.js'\nimport { retryPlugin } from './src/plugins/retry.js'\nimport { ConfigManager } from './src/config_manager.js'\nimport { ExceptionsManager } from './src/exceptions_manager.js'\nimport { createTest, createTestGroup } from './src/create_test.js'\nimport type { CLIArgs, Config, NormalizedConfig } from './src/types.js'\nimport { Emitter, Group, Runner, Suite, Test, TestContext } from './modules/core/main.js'\n\n/**\n * Global emitter instance used by the test\n */\nconst emitter = new Emitter()\n\n/**\n * The current active test\n */\nlet activeTest: Test<any> | undefined\n\n/**\n * Parsed commandline arguments\n */\nlet cliArgs: CLIArgs = {}\n\n/**\n * Hydrated config\n */\nlet runnerConfig: NormalizedConfig | undefined\n\n/**\n * The state refers to the phase where we configure suites and import\n * test files. We stick this metadata to the test instance one can\n * later reference within the test.\n */\nconst executionPlanState: {\n  phase: 'idle' | 'planning' | 'executing'\n  file?: string\n  suite?: Suite\n  group?: Group\n  timeout?: number\n  retries?: number\n} = {\n  phase: 'idle',\n}\n\n/**\n * Create a Japa test. Defining a test without the callback\n * will create a todo test.\n */\nexport function test(title: string, callback?: TestExecutor<TestContext, undefined>) {\n  validator.ensureIsInPlanningPhase(executionPlanState.phase)\n\n  const testInstance = createTest(title, emitter, runnerConfig!.refiner, executionPlanState)\n  testInstance.setup((t) => {\n    activeTest = t\n    return () => {\n      activeTest = undefined\n    }\n  })\n\n  if (callback) {\n    testInstance.run(callback)\n  }\n\n  return testInstance\n}\n\n/**\n * Create a Japa test group\n */\ntest.group = function (title: string, callback: (group: Group) => void) {\n  validator.ensureIsInPlanningPhase(executionPlanState.phase)\n\n  executionPlanState.group = createTestGroup(\n    title,\n    emitter,\n    runnerConfig!.refiner,\n    executionPlanState\n  )\n  callback(executionPlanState.group)\n  executionPlanState.group = undefined\n}\n\n/**\n * Get the test of currently running test\n */\nexport function getActiveTest() {\n  return activeTest\n}\n\n/**\n * Make Japa process command line arguments. Later the parsed output\n * will be used by Japa to compute the configuration\n */\nexport function processCLIArgs(argv: string[]) {\n  cliArgs = new CliParser().parse(argv)\n}\n\n/**\n * Configure the tests runner with inline configuration. You must\n * call configure method before the run method.\n *\n * Do note: The CLI flags will overwrite the options provided\n * to the configure method.\n */\nexport function configure(options: Config) {\n  runnerConfig = new ConfigManager(options, cliArgs).hydrate()\n}\n\n/**\n * Execute Japa tests. Calling this function will import the test\n * files behind the scenes\n */\nexport async function run() {\n  /**\n   * Display help when help flag is used\n   */\n  if (cliArgs.help) {\n    console.log(new CliParser().getHelp())\n    return\n  }\n\n  validator.ensureIsConfigured(runnerConfig)\n\n  executionPlanState.phase = 'planning'\n  const runner = new Runner(emitter)\n  const globalHooks = new GlobalHooks()\n  const exceptionsManager = new ExceptionsManager()\n\n  try {\n    /**\n     * Executing the retry plugin as the first thing\n     */\n    await retryPlugin({ config: runnerConfig!, runner, emitter, cliArgs })\n\n    /**\n     * Step 1: Executing plugins before creating a plan, so that it can mutate\n     * the config\n     */\n    for (let plugin of runnerConfig!.plugins) {\n      debug('executing \"%s\" plugin', plugin.name || 'anonymous')\n      await plugin({ runner, emitter, cliArgs, config: runnerConfig! })\n    }\n\n    /**\n     * Step 2: Creating an execution plan. The output is the result of\n     * applying all the filters and validations.\n     */\n    const { config, reporters, suites, refinerFilters } = await new Planner(runnerConfig!).plan()\n\n    /**\n     * Step 3: Registering reporters and filters with the runner\n     */\n    reporters.forEach((reporter) => {\n      debug('registering \"%s\" reporter', reporter.name)\n      runner.registerReporter(reporter)\n    })\n    refinerFilters.forEach((filter) => {\n      debug('apply %s filters \"%O\" ', filter.layer, filter.filters)\n      config.refiner.add(filter.layer, filter.filters)\n    })\n    config.refiner.matchAllTags(cliArgs.matchAll ?? false)\n    runner.onSuite(config.configureSuite)\n\n    /**\n     * Step 4: Running the setup hooks\n     */\n    debug('executing global hooks')\n    globalHooks.apply(config)\n    await globalHooks.setup(runner)\n\n    /**\n     * Step 5: Register suites and import test files\n     */\n    for (let suite of suites) {\n      /**\n       * Creating and configuring the suite\n       */\n      executionPlanState.suite = new Suite(suite.name, emitter, config.refiner)\n      executionPlanState.retries = suite.retries\n      executionPlanState.timeout = suite.timeout\n      if (typeof suite.configure === 'function') {\n        suite.configure(executionPlanState.suite)\n      }\n      runner.add(executionPlanState.suite)\n\n      /**\n       * Importing suite files\n       */\n      for (let fileURL of suite.filesURLs) {\n        executionPlanState.file = fileURLToPath(fileURL)\n        debug('importing test file %s', executionPlanState.file)\n        await config.importer(fileURL)\n      }\n\n      /**\n       * Resetting global state\n       */\n      executionPlanState.suite = undefined\n    }\n\n    /**\n     * Onto execution phase\n     */\n    executionPlanState.phase = 'executing'\n\n    /**\n     * Monitor for unhandled erorrs and rejections\n     */\n    exceptionsManager.monitor()\n\n    await runner.start()\n    await runner.exec()\n\n    await globalHooks.teardown(null, runner)\n    await runner.end()\n\n    /**\n     * Print unhandled errors\n     */\n    await exceptionsManager.flow()\n\n    const summary = runner.getSummary()\n    if (summary.hasError || exceptionsManager.hasErrors) {\n      process.exitCode = 1\n    }\n    if (config.forceExit) {\n      process.exit()\n    }\n  } catch (error) {\n    await globalHooks.teardown(error, runner)\n    const printer = new ErrorsPrinter()\n    await printer.printError(error)\n\n    /**\n     * Print unhandled errors in case the code inside\n     * the try block never got triggered\n     */\n    await exceptionsManager.flow()\n\n    process.exitCode = 1\n    if (runnerConfig!.forceExit) {\n      process.exit()\n    }\n  }\n}\n","/*\n * @japa/runner\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { join } from 'node:path'\nimport findCacheDirectory from 'find-cache-dir'\nimport { mkdir, readFile, unlink, writeFile } from 'node:fs/promises'\n\nimport { colors } from '../helpers.js'\nimport type { PluginFn } from '../types.js'\n\n/**\n * Paths to the cache directory and the summary file\n */\nconst CACHE_DIR = findCacheDirectory({ name: '@japa/runner' })\nconst SUMMARY_FILE = CACHE_DIR ? join(CACHE_DIR, 'summary.json') : undefined\n\n/**\n * Returns an object with the title of the tests failed during\n * the last run.\n */\nexport async function getFailedTests(): Promise<{ tests?: string[] }> {\n  try {\n    const summary = await readFile(SUMMARY_FILE!, 'utf-8')\n    return JSON.parse(summary)\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      return {}\n    }\n    throw new Error('Unable to read failed tests cache file', { cause: error })\n  }\n}\n\n/**\n * Writes failing tests to the cache directory\n */\nexport async function cacheFailedTests(tests: string[]) {\n  await mkdir(CACHE_DIR!, { recursive: true })\n  await writeFile(SUMMARY_FILE!, JSON.stringify({ tests: tests }))\n}\n\n/**\n * Clears the cache dir\n */\nexport async function clearCache() {\n  await unlink(SUMMARY_FILE!)\n}\n\n/**\n * Exposes the API to run failing tests using the \"failed\" CLI flag.\n */\nexport const retryPlugin: PluginFn = async function retry({ config, cliArgs }) {\n  if (!SUMMARY_FILE) {\n    return\n  }\n\n  config.teardown.push(async (runner) => {\n    const summary = runner.getSummary()\n    await cacheFailedTests(summary.failedTestsTitles)\n  })\n\n  if (cliArgs.failed) {\n    try {\n      const { tests } = await getFailedTests()\n      if (!tests || !tests.length) {\n        console.log(colors.bgYellow().black(' No failing tests found. Running all the tests '))\n        return\n      }\n      config.filters.tests = tests\n    } catch (error) {\n      console.log(colors.bgRed().black(' Unable to read failed tests. Running all the tests '))\n      console.log(colors.red(error))\n    }\n  }\n}\n","/*\n * @japa/runner\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ErrorsPrinter } from '@japa/errors-printer'\n\n/**\n * Handles uncaught exceptions and prints them to the\n * console\n */\nexport class ExceptionsManager {\n  #exceptionsBuffer: any[] = []\n  #rejectionsBuffer: any[] = []\n  #state: 'watching' | 'flowing' = 'watching'\n  #errorsPrinter = new ErrorsPrinter({ stackLinesCount: 2, framesMaxLimit: 4 })\n\n  hasErrors: boolean = false\n\n  /**\n   * Monitors unhandled exceptions and rejections. The exceptions\n   * are stacked in a buffer, so that we do not clutter the\n   * tests output and once the tests are over, we will\n   * print them to the console.\n   *\n   * In case the tests are completed, we will print errors as they\n   * happen.\n   */\n  monitor() {\n    process.on('uncaughtException', async (error) => {\n      this.hasErrors = true\n      if (this.#state === 'watching') {\n        this.#exceptionsBuffer.push(error)\n      } else {\n        this.#errorsPrinter.printSectionBorder('[Unhandled Error]')\n        await this.#errorsPrinter.printError(error)\n        process.exitCode = 1\n      }\n    })\n\n    process.on('unhandledRejection', async (error) => {\n      this.hasErrors = true\n      if (this.#state === 'watching') {\n        this.#rejectionsBuffer.push(error)\n      } else {\n        this.#errorsPrinter.printSectionBorder('[Unhandled Rejection]')\n        await this.#errorsPrinter.printError(error)\n        process.exitCode = 1\n      }\n    })\n  }\n\n  async flow() {\n    if (this.#state === 'flowing') {\n      return\n    }\n\n    this.#state = 'flowing'\n\n    /**\n     * Print exceptions\n     */\n    if (this.#exceptionsBuffer.length) {\n      let exceptionsCount = this.#exceptionsBuffer.length\n      let exceptionsIndex = this.#exceptionsBuffer.length\n      this.#errorsPrinter.printSectionHeader('Unhandled Errors')\n      for (let exception of this.#exceptionsBuffer) {\n        await this.#errorsPrinter.printError(exception)\n        this.#errorsPrinter.printSectionBorder(`[${++exceptionsIndex}/${exceptionsCount}]`)\n      }\n      this.#exceptionsBuffer = []\n    }\n\n    /**\n     * Print rejections\n     */\n    if (this.#rejectionsBuffer.length) {\n      let rejectionsCount = this.#exceptionsBuffer.length\n      let rejectionsIndex = this.#exceptionsBuffer.length\n      this.#errorsPrinter.printSectionBorder('Unhandled Rejections')\n      for (let rejection of this.#rejectionsBuffer) {\n        await this.#errorsPrinter.printError(rejection)\n        this.#errorsPrinter.printSectionBorder(`[${++rejectionsIndex}/${rejectionsCount}]`)\n      }\n      this.#rejectionsBuffer = []\n    }\n  }\n}\n"],"mappings":"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","names":["ErrorsPrinter","cliArgs","ErrorsPrinter"]}