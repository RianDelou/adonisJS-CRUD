import {
  BaseReporter,
  colors,
  icons
} from "./chunk-BFNOUWI5.js";

// src/reporters/dot.ts
var DotReporter = class extends BaseReporter {
  /**
   * When a test ended
   */
  onTestEnd(payload) {
    let output = "";
    if (payload.isTodo) {
      output = colors.cyan(icons.info);
    } else if (payload.hasError || payload.isFailing) {
      output = payload.hasError ? colors.magenta(icons.squareSmallFilled) : colors.red(icons.cross);
    } else if (payload.isSkipped) {
      output = colors.yellow(icons.bullet);
    } else {
      output = colors.green(icons.tick);
    }
    process.stdout.write(`${output}`);
  }
  /**
   * When test runner ended
   */
  async end() {
    console.log("");
    await this.printSummary(this.runner.getSummary());
  }
};

// src/reporters/spec.ts
import ms from "ms";
import { relative } from "node:path";
var SpecReporter = class extends BaseReporter {
  /**
   * Tracking if the first event we get is for a test without any parent group
   * We need this to decide the display style for tests without groups.
   */
  #isFirstLoneTest = true;
  /**
   * Returns the icon for the test
   */
  #getTestIcon(payload) {
    if (payload.isTodo) {
      return colors.cyan(icons.info);
    }
    if (payload.isFailing) {
      return payload.hasError ? colors.magenta(icons.squareSmallFilled) : colors.red(icons.cross);
    }
    if (payload.hasError) {
      return colors.red(icons.cross);
    }
    if (payload.isSkipped) {
      return colors.yellow(icons.bullet);
    }
    return colors.green(icons.tick);
  }
  /**
   * Returns the test message
   */
  #getTestMessage(payload) {
    const message = payload.title.expanded;
    if (payload.isTodo) {
      return colors.blue(message);
    }
    if (payload.isFailing) {
      return payload.hasError ? colors.magenta(message) : colors.red(message);
    }
    if (payload.hasError) {
      return colors.red(message);
    }
    if (payload.isSkipped) {
      return colors.yellow(message);
    }
    return colors.grey(message);
  }
  /**
   * Returns the subtext message for the test
   */
  #getSubText(payload) {
    if (payload.isSkipped && payload.skipReason) {
      return colors.yellow(payload.skipReason);
    }
    if (!payload.isFailing) {
      return;
    }
    if (!payload.hasError) {
      return colors.magenta(`Test marked with ".fails()" must finish with an error`);
    }
    if (payload.failReason) {
      return colors.magenta(payload.failReason);
    }
    const testErrorMessage = payload.errors.find((error) => error.phase === "test");
    if (testErrorMessage && testErrorMessage.error) {
      return colors.magenta(testErrorMessage.error.message);
    }
  }
  /**
   * Returns the filename relative from the current working dir
   */
  #getRelativeFilename(fileName) {
    return relative(process.cwd(), fileName);
  }
  /**
   * Prints the test details
   */
  #printTest(payload) {
    const icon = this.#getTestIcon(payload);
    const message = this.#getTestMessage(payload);
    const prefix = payload.isPinned ? colors.yellow("[PINNED] ") : "";
    const indentation = this.currentFileName || this.currentGroupName ? "  " : "";
    const duration = colors.dim(`(${ms(Number(payload.duration.toFixed(2)))})`);
    const retries = payload.retryAttempt && payload.retryAttempt > 1 ? colors.dim(`(x${payload.retryAttempt}) `) : "";
    let subText = this.#getSubText(payload);
    subText = subText ? `
${indentation}  ${subText}` : "";
    console.log(`${indentation}${icon} ${prefix}${retries}${message} ${duration}${subText}`);
  }
  /**
   * Prints the group name
   */
  #printGroup(payload) {
    const title = this.currentSuiteName !== "default" ? `${this.currentSuiteName} / ${payload.title}` : payload.title;
    const suffix = this.currentFileName ? colors.dim(` (${this.#getRelativeFilename(this.currentFileName)})`) : "";
    console.log(`
${title}${suffix}`);
  }
  onTestStart() {
    if (this.currentFileName && this.#isFirstLoneTest) {
      console.log(`
${colors.dim(this.#getRelativeFilename(this.currentFileName))}`);
    }
    this.#isFirstLoneTest = false;
  }
  onTestEnd(payload) {
    this.#printTest(payload);
  }
  onGroupStart(payload) {
    this.#isFirstLoneTest = false;
    this.#printGroup(payload);
  }
  onGroupEnd() {
    this.#isFirstLoneTest = true;
  }
  async end() {
    const summary = this.runner.getSummary();
    await this.printSummary(summary);
  }
};

// src/reporters/ndjson.ts
import { relative as relative2 } from "node:path";
import { serializeError } from "serialize-error";
var NdJSONReporter = class extends BaseReporter {
  /**
   * Returns the filename relative from the current working dir
   */
  #getRelativeFilename(fileName) {
    return relative2(process.cwd(), fileName);
  }
  /**
   * Serialize errors to JSON
   */
  #serializeErrors(errors) {
    return errors.map((error) => ({
      phase: error.phase,
      error: serializeError(error.error)
    }));
  }
  onTestEnd(payload) {
    console.log(
      JSON.stringify({
        event: "test:end",
        filePath: this.currentFileName,
        relativePath: this.currentFileName ? this.#getRelativeFilename(this.currentFileName) : void 0,
        title: payload.title,
        duration: payload.duration,
        failReason: payload.failReason,
        isFailing: payload.isFailing,
        skipReason: payload.skipReason,
        isSkipped: payload.isSkipped,
        isTodo: payload.isTodo,
        isPinned: payload.isPinned,
        retryAttempt: payload.retryAttempt,
        retries: payload.retries,
        errors: this.#serializeErrors(payload.errors)
      })
    );
  }
  onGroupStart(payload) {
    console.log(
      JSON.stringify({
        event: "group:start",
        title: payload.title
      })
    );
  }
  onGroupEnd(payload) {
    JSON.stringify({
      event: "group:end",
      title: payload.title,
      errors: this.#serializeErrors(payload.errors)
    });
  }
  onSuiteStart(payload) {
    console.log(
      JSON.stringify({
        event: "suite:start",
        ...payload
      })
    );
  }
  onSuiteEnd(payload) {
    console.log(
      JSON.stringify({
        event: "suite:end",
        ...payload
      })
    );
  }
  async end() {
    const summary = this.runner.getSummary();
    console.log(
      JSON.stringify({
        aggregates: summary.aggregates,
        duration: summary.duration,
        failedTestsTitles: summary.failedTestsTitles,
        hasError: summary.hasError
      })
    );
  }
};

// src/reporters/main.ts
var spec = (options) => {
  return {
    name: "spec",
    handler: (...args) => new SpecReporter(options).boot(...args)
  };
};
var dot = (options) => {
  return {
    name: "dot",
    handler: (...args) => new DotReporter(options).boot(...args)
  };
};
var ndjson = (options) => {
  return {
    name: "ndjson",
    handler: (...args) => new NdJSONReporter(options).boot(...args)
  };
};

export {
  spec,
  dot,
  ndjson
};
//# sourceMappingURL=chunk-PHC5CJQG.js.map