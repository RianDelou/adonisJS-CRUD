{"version":3,"sources":["../src/runner.ts","../src/debug.ts","../src/tracker.ts","../src/summary_builder.ts","../src/test/main.ts","../src/test/runner.ts","../src/interpolate.ts","../src/emitter.ts","../src/group/main.ts","../src/group/runner.ts","../src/refiner.ts","../src/suite/main.ts","../src/suite/runner.ts","../src/test_context.ts"],"sourcesContent":["/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport Macroable from '@poppinss/macroable'\n\nimport debug from './debug.js'\nimport { Suite } from './suite/main.js'\nimport { Emitter } from './emitter.js'\nimport { Tracker } from './tracker.js'\nimport { ReporterContract, RunnerSummary } from './types.js'\nimport { SummaryBuilder } from './summary_builder.js'\n\n/**\n * The Runner class exposes the API to register test suites and execute\n * them sequentially.\n *\n * @example\n * const runner = new Runner(emitter)\n * const suite = new Suite('unit', emitter)\n *\n * runner.add(suite)\n * runner.registerReporter(reporters.list)\n *\n * await runner.exec()\n */\nexport class Runner<Context extends Record<any, any>> extends Macroable {\n  #emitter: Emitter\n\n  /**\n   * Callbacks to invoke on every suite\n   */\n  #configureSuiteCallbacks: ((suite: Suite<Context>) => void)[] = []\n\n  /**\n   * Reference to tests tracker\n   */\n  #tracker?: Tracker\n\n  /**\n   * Summary builder is used to create the tests summary reported by\n   * multiple reporters. Each report contains a key-value pair\n   */\n  summaryBuilder = new SummaryBuilder()\n\n  /**\n   * A collection of suites\n   */\n  suites: Suite<Context>[] = []\n\n  /**\n   * Registered tests reporter\n   */\n  reporters: Set<ReporterContract> = new Set()\n\n  constructor(emitter: Emitter) {\n    super()\n    this.#emitter = emitter\n  }\n\n  /**\n   * Notify the reporter about the runner start\n   */\n  #notifyStart() {\n    return this.#emitter.emit('runner:start', {})\n  }\n\n  /**\n   * Notify the reporter about the runner end\n   */\n  #notifyEnd() {\n    return this.#emitter.emit('runner:end', {})\n  }\n\n  /**\n   * Boot the runner\n   */\n  #boot() {\n    this.#tracker = new Tracker()\n\n    this.#emitter.on('runner:start', (payload) =>\n      this.#tracker?.processEvent('runner:start', payload)\n    )\n    this.#emitter.on('runner:end', (payload) => this.#tracker?.processEvent('runner:end', payload))\n    this.#emitter.on('suite:start', (payload) =>\n      this.#tracker?.processEvent('suite:start', payload)\n    )\n    this.#emitter.on('suite:end', (payload) => this.#tracker?.processEvent('suite:end', payload))\n    this.#emitter.on('group:start', (payload) =>\n      this.#tracker?.processEvent('group:start', payload)\n    )\n    this.#emitter.on('group:end', (payload) => this.#tracker?.processEvent('group:end', payload))\n    this.#emitter.on('test:start', (payload) => this.#tracker?.processEvent('test:start', payload))\n    this.#emitter.on('test:end', (payload) => this.#tracker?.processEvent('test:end', payload))\n  }\n\n  /**\n   * Add a suite to the runner\n   */\n  add(suite: Suite<Context>): this {\n    this.#configureSuiteCallbacks.forEach((callback) => callback(suite))\n    this.suites.push(suite)\n    debug('registering suite %s', suite.name)\n    return this\n  }\n\n  /**\n   * Tap into each suite and configure it\n   */\n  onSuite(callback: (suite: Suite<Context>) => void): this {\n    this.suites.forEach((suite) => callback(suite))\n    this.#configureSuiteCallbacks.push(callback)\n    return this\n  }\n\n  /**\n   * Register a tests reporter\n   */\n  registerReporter(reporter: ReporterContract): this {\n    this.reporters.add(reporter)\n    return this\n  }\n\n  /**\n   * Get tests summary\n   */\n  getSummary(): RunnerSummary {\n    return this.#tracker!.getSummary()\n  }\n\n  /**\n   * Start the test runner process. The method emits\n   * \"runner:start\" event\n   */\n  async start() {\n    this.#boot()\n    debug('starting to run tests')\n\n    for (let reporter of this.reporters) {\n      if (typeof reporter === 'function') {\n        await reporter(this, this.#emitter)\n      } else {\n        await reporter.handler(this, this.#emitter)\n      }\n    }\n\n    await this.#notifyStart()\n  }\n\n  /**\n   * Execute runner suites\n   */\n  async exec() {\n    for (let suite of this.suites) {\n      await suite.exec()\n    }\n  }\n\n  /**\n   * End the runner process. Emits \"runner:end\" event\n   */\n  async end() {\n    await this.#notifyEnd()\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { debuglog } from 'node:util'\n\nexport default debuglog('japa:core')\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport timeSpan, { TimeEndFunction } from 'time-span'\nimport type {\n  TestEndNode,\n  GroupEndNode,\n  SuiteEndNode,\n  RunnerEvents,\n  RunnerSummary,\n  GroupStartNode,\n  SuiteStartNode,\n  FailureTreeGroupNode,\n  FailureTreeSuiteNode,\n} from './types.js'\n\n/**\n * Tracks the tests events to generate a summary report. Failing tests are further tracked\n * for complete hierarchy\n */\nexport class Tracker {\n  /**\n   * Time tracker to find runner duration\n   */\n  #timeTracker?: TimeEndFunction\n\n  /**\n   * Currently active suite\n   */\n  #currentSuite?: FailureTreeSuiteNode\n\n  /**\n   * Currently active group\n   */\n  #currentGroup?: FailureTreeGroupNode\n\n  /**\n   * If the entire run cycle has one or more errors\n   */\n  #hasError: boolean = false\n\n  /**\n   * Storing state if current suite and group has errors. These\n   * errors are not directly from the suite and groups, but\n   * instead from their children.\n   *\n   * For example: If a test fails, it marks both current group\n   * and suite has errors.\n   */\n  #currentSuiteHasError = false\n  #currentGroupHasError = false\n\n  #aggregates: RunnerSummary['aggregates'] = {\n    total: 0,\n    failed: 0,\n    passed: 0,\n    regression: 0,\n    skipped: 0,\n    todo: 0,\n  }\n\n  #duration: number = 0\n\n  /**\n   * A tree of suites/groups and tests that have failed. They are always nested inside\n   * other unless the test groups where used, then suites contains a list of tests\n   * directly.\n   */\n  #failureTree: FailureTreeSuiteNode[] = []\n  #failedTestsTitles: string[] = []\n\n  /**\n   * Set reference for the current suite\n   */\n  #onSuiteStart(payload: SuiteStartNode) {\n    this.#currentSuiteHasError = false\n    this.#currentSuite = {\n      name: payload.name,\n      type: 'suite',\n      errors: [],\n      children: [],\n    }\n  }\n\n  /**\n   * Move suite to the failure tree when the suite\n   * has errors\n   */\n  #onSuiteEnd(payload: SuiteEndNode) {\n    if (payload.hasError) {\n      this.#hasError = true\n      this.#currentSuiteHasError = true\n      this.#currentSuite!.errors = payload.errors\n    }\n\n    if (this.#currentSuiteHasError) {\n      this.#failureTree.push(this.#currentSuite!)\n    }\n  }\n\n  /**\n   * Set reference for the current group\n   */\n  #onGroupStart(payload: GroupStartNode) {\n    this.#currentGroupHasError = false\n    this.#currentGroup = {\n      name: payload.title,\n      type: 'group',\n      errors: [],\n      children: [],\n    }\n  }\n\n  /**\n   * Move suite to the failure tree when the suite\n   * has errors\n   */\n  #onGroupEnd(payload: GroupEndNode) {\n    if (payload.hasError) {\n      this.#hasError = true\n      this.#currentGroupHasError = true\n      this.#currentGroup!.errors = payload.errors\n    }\n\n    if (this.#currentGroupHasError) {\n      this.#currentSuiteHasError = true\n      this.#currentSuite!.children.push(this.#currentGroup!)\n    }\n  }\n\n  /**\n   * In case of failure, track the test inside the current group\n   * or the current suite.\n   */\n  #onTestEnd(payload: TestEndNode) {\n    /**\n     * Bumping aggregates\n     */\n    this.#aggregates.total++\n\n    /**\n     * Test was skipped\n     */\n    if (payload.isSkipped) {\n      this.#aggregates.skipped++\n      return\n    }\n\n    /**\n     * Test was a todo\n     */\n    if (payload.isTodo) {\n      this.#aggregates.todo++\n      return\n    }\n\n    /**\n     * Regression test. Mark test as failed, when there is no error\n     * Because, we expect regression tests to have errors.\n     *\n     * However, there is no need to move anything to the failure\n     * tree, since there is no real error\n     */\n    if (payload.isFailing) {\n      if (!payload.hasError) {\n        this.#aggregates.failed++\n        this.#hasError = true\n      } else {\n        this.#aggregates.regression++\n      }\n\n      return\n    }\n\n    /**\n     * Test completed successfully\n     */\n    if (!payload.hasError) {\n      this.#aggregates.passed++\n      return\n    }\n\n    this.#markTestAsFailed(payload)\n  }\n\n  /**\n   * Mark test as failed\n   */\n  #markTestAsFailed(payload: TestEndNode) {\n    /**\n     * Bump failed count\n     */\n    this.#aggregates.failed++\n    this.#hasError = true\n\n    /**\n     * Test payload\n     */\n    const testPayload = {\n      type: 'test' as const,\n      title: payload.title.expanded,\n      errors: payload.errors,\n    }\n\n    /**\n     * Track test inside the current group or suite\n     */\n    if (this.#currentGroup) {\n      this.#currentGroupHasError = true\n      this.#currentGroup.children.push(testPayload)\n    } else if (this.#currentSuite) {\n      this.#currentSuiteHasError = true\n      this.#currentSuite.children.push(testPayload)\n    }\n\n    /**\n     * Push title to the failedTestsTitles array\n     */\n    this.#failedTestsTitles.push(payload.title.original)\n  }\n\n  /**\n   * Process the tests events\n   */\n  processEvent<Event extends keyof RunnerEvents>(\n    event: keyof RunnerEvents,\n    payload: RunnerEvents[Event]\n  ) {\n    switch (event) {\n      case 'suite:start':\n        this.#onSuiteStart(payload as SuiteStartNode)\n        break\n      case 'suite:end':\n        this.#onSuiteEnd(payload as SuiteEndNode)\n        break\n      case 'group:start':\n        this.#onGroupStart(payload as GroupStartNode)\n        break\n      case 'group:end':\n        this.#onGroupEnd(payload as GroupEndNode)\n        break\n      case 'test:end':\n        this.#onTestEnd(payload as TestEndNode)\n        break\n      case 'runner:start':\n        this.#timeTracker = timeSpan()\n        break\n      case 'runner:end':\n        this.#duration = this.#timeTracker?.rounded() ?? 0\n        break\n    }\n  }\n\n  /**\n   * Returns the tests runner summary\n   */\n  getSummary(): RunnerSummary {\n    return {\n      aggregates: this.#aggregates,\n      hasError: this.#hasError,\n      duration: this.#duration,\n      failureTree: this.#failureTree,\n      failedTestsTitles: this.#failedTestsTitles,\n    }\n  }\n}\n","/*\n * @japa/runner\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport stringWidth from 'string-width'\nimport { justify } from '@poppinss/cliui/helpers'\n\n/**\n * Summary builder is used to create the tests summary reported by\n * multiple reporters. Each report contains a key-value pair\n */\nexport class SummaryBuilder {\n  #reporters: (() => { key: string; value: string | string[] }[])[] = []\n\n  /**\n   * Register a custom summary reporter\n   */\n  use(reporter: () => { key: string; value: string | string[] }[]): this {\n    this.#reporters.push(reporter)\n    return this\n  }\n\n  /**\n   * Builds the summary table\n   */\n  build(): string[] {\n    const keys: string[] = []\n    const keysLengths: number[] = []\n    const values: string[][] = []\n\n    this.#reporters.forEach((reporter) => {\n      const reports = reporter()\n      reports.forEach((report) => {\n        keys.push(report.key)\n        values.push(Array.isArray(report.value) ? report.value : [report.value])\n        keysLengths.push(stringWidth(report.key))\n      })\n    })\n\n    const largestKey = Math.max(...keysLengths)\n    const keysRows = justify(keys, { maxWidth: largestKey, align: 'right', paddingChar: ' ' })\n\n    return keysRows.map((key, index) => {\n      return `${key}${values[index]\n        .map((line, i) => {\n          return i === 0 ? `  ${line}` : `${' '.repeat(largestKey)}  ${line}`\n        })\n        .join('\\n')}`\n    })\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport Hooks from '@poppinss/hooks'\nimport Macroable from '@poppinss/macroable'\n\nimport debug from '../debug.js'\nimport { Group } from '../group/main.js'\nimport { Emitter } from '../emitter.js'\nimport { Refiner } from '../refiner.js'\nimport { DummyRunner, TestRunner } from './runner.js'\nimport type {\n  TestHooks,\n  DataSetNode,\n  TestEndNode,\n  TestOptions,\n  TestExecutor,\n  TestHooksHandler,\n  TestHooksCleanupHandler,\n} from '../types.js'\n\n/**\n * Test class exposes a self contained API to configure and run\n * tests along with its hooks.\n *\n * @example\n * const test = new Test('2 + 2 = 4', emitter, refiner)\n *\n * test.run(async ({ assert }) => {\n *   assert.equal(2 + 2 , 4)\n * })\n */\nexport class Test<\n  Context extends Record<any, any>,\n  TestData extends DataSetNode = undefined,\n> extends Macroable {\n  /**\n   * Methods to call before the test callback is executed\n   */\n  static executingCallbacks: ((test: Test<any, any>) => void)[] = []\n\n  /**\n   * Methods to call after the test callback is executed\n   */\n  static executedCallbacks: ((\n    test: Test<any, any>,\n    hasError: boolean,\n    errors: TestEndNode['errors']\n  ) => void)[] = []\n\n  /**\n   * Define a synchronous function to call before running\n   * the test executor callback\n   *\n   * Do note: Async methods are not allowed\n   */\n  static executing(callback: (test: Test<any, any>) => void): void {\n    this.executingCallbacks.push(callback)\n  }\n\n  /**\n   * Define a synchronous function to call after running\n   * the test executor callback\n   *\n   * Do note: Async methods are not allowed\n   */\n  static executed(\n    callback: (test: Test<any, any>, hasError: boolean, errors: TestEndNode['errors']) => void\n  ): void {\n    this.executedCallbacks.push(callback)\n  }\n\n  #refiner: Refiner\n  #emitter: Emitter\n\n  /**\n   * Reference to the active runner running the\n   * test\n   */\n  #activeRunner?: TestRunner\n\n  /**\n   * Check if the test has been executed\n   */\n  #executed: boolean = false\n\n  /**\n   * Reference to registered hooks\n   */\n  #hooks = new Hooks<TestHooks<Context>>()\n\n  /**\n   * The function for creating the test context\n   */\n  #contextAccumlator?: (test: this) => Context | Promise<Context>\n\n  /**\n   * The function for computing if test should\n   * be skipped or not\n   */\n  #skipAccumulator?: () => Promise<boolean> | boolean\n\n  /**\n   * The function that returns the test data set\n   */\n  #datasetAccumlator?: () => Promise<any[]> | any[]\n\n  /**\n   * Test options\n   */\n  options: TestOptions\n\n  /**\n   * Reference to the test dataset\n   */\n  dataset?: any[]\n\n  /**\n   * Reference to the test context. Available at the time\n   * of running the test\n   */\n  context!: Context\n\n  /**\n   * Find if the test is pinned\n   */\n  get isPinned() {\n    return this.#refiner.isPinned(this)\n  }\n\n  constructor(\n    public title: string,\n    context: Context | ((test: Test<Context, TestData>) => Context | Promise<Context>),\n    emitter: Emitter,\n    refiner: Refiner,\n    public parent?: Group<Context>\n  ) {\n    super()\n\n    this.#emitter = emitter\n    this.#refiner = refiner\n    this.options = {\n      title: this.title,\n      tags: [],\n      timeout: 2000,\n      meta: {},\n    }\n\n    /**\n     * Make sure the instantiated class has its own property \"executingCallbacks\"\n     * and \"executedCallbacks\"\n     */\n    if (!this.constructor.hasOwnProperty('executingCallbacks')) {\n      throw new Error(\n        `Define static property \"executingCallbacks = []\" on ${this.constructor.name} class`\n      )\n    }\n    if (!this.constructor.hasOwnProperty('executedCallbacks')) {\n      throw new Error(\n        `Define static property \"executedCallbacks = []\" on ${this.constructor.name} class`\n      )\n    }\n\n    if (typeof context === 'function') {\n      this.#contextAccumlator = context as (\n        test: Test<Context, TestData>\n      ) => Context | Promise<Context>\n    } else {\n      this.context = context\n    }\n  }\n\n  /**\n   * Find if test should be skipped\n   */\n  async #computeShouldSkip() {\n    if (this.#skipAccumulator) {\n      this.options.isSkipped = await this.#skipAccumulator()\n    }\n  }\n\n  /**\n   * Find if test is a todo\n   */\n  #computeisTodo() {\n    this.options.isTodo = !this.options.executor\n  }\n\n  /**\n   * Returns the dataset array or undefined\n   */\n  async #computeDataset(): Promise<any[] | undefined> {\n    if (typeof this.#datasetAccumlator === 'function') {\n      this.dataset = await this.#datasetAccumlator()\n    }\n\n    return this.dataset\n  }\n\n  /**\n   * Get context instance for the test\n   */\n  async #computeContext(): Promise<Context> {\n    if (typeof this.#contextAccumlator === 'function') {\n      this.context = await this.#contextAccumlator(this)\n    }\n\n    return this.context!\n  }\n\n  /**\n   * Skip the test conditionally\n   */\n  skip(skip: boolean | (() => Promise<boolean> | boolean) = true, skipReason?: string): this {\n    if (typeof skip === 'function') {\n      this.#skipAccumulator = skip\n    } else {\n      this.options.isSkipped = skip\n    }\n\n    this.options.skipReason = skipReason\n    return this\n  }\n\n  /**\n   * Expect the test to fail. Helpful in creating test cases\n   * to showcase bugs\n   */\n  fails(failReason?: string): this {\n    this.options.isFailing = true\n    this.options.failReason = failReason\n    return this\n  }\n\n  /**\n   * Define custom timeout for the test\n   */\n  timeout(timeout: number): this {\n    this.options.timeout = timeout\n    return this\n  }\n\n  /**\n   * Disable test timeout. It is same as calling `test.timeout(0)`\n   */\n  disableTimeout(): this {\n    return this.timeout(0)\n  }\n\n  /**\n   * Reset the timeout from within the test callback.\n   */\n  resetTimeout(duration?: number): this {\n    if (this.#activeRunner) {\n      this.#activeRunner.resetTimeout(duration)\n    } else {\n      if (duration) {\n        this.timeout(duration)\n      } else {\n        this.disableTimeout()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Assign tags to the test. Later you can use the tags to run\n   * specific tests\n   */\n  tags(tags: string[], strategy: 'replace' | 'append' | 'prepend' = 'replace'): this {\n    if (strategy === 'replace') {\n      this.options.tags = tags\n      return this\n    }\n\n    if (strategy === 'prepend') {\n      this.options.tags = tags.concat(this.options.tags)\n      return this\n    }\n\n    this.options.tags = this.options.tags.concat(tags)\n    return this\n  }\n\n  /**\n   * Configure the number of times this test should be retried\n   * when failing.\n   */\n  retry(retries: number): this {\n    this.options.retries = retries\n    return this\n  }\n\n  /**\n   * Wait for the test executor to call done method\n   */\n  waitForDone(): this {\n    this.options.waitsForDone = true\n    return this\n  }\n\n  /**\n   * Pin current test. Pinning a test will only run the\n   * pinned tests.\n   */\n  pin(): this {\n    this.#refiner.pinTest(this)\n    return this\n  }\n\n  /**\n   * Define the dataset for the test. The test executor will be invoked\n   * for all the items inside the dataset array\n   */\n  with<Dataset extends DataSetNode>(dataset: Dataset): Test<Context, Dataset> {\n    if (Array.isArray(dataset)) {\n      this.dataset = dataset\n      return this as unknown as Test<Context, Dataset>\n    }\n\n    if (typeof dataset === 'function') {\n      this.#datasetAccumlator = dataset\n      return this as unknown as Test<Context, Dataset>\n    }\n\n    throw new Error('dataset must be an array or a function that returns an array')\n  }\n\n  /**\n   * Define the test executor function\n   */\n  run(executor: TestExecutor<Context, TestData>): this {\n    this.options.executor = executor\n    return this\n  }\n\n  /**\n   * Register a test setup function\n   */\n  setup(handler: TestHooksHandler<Context>): this {\n    debug('registering \"%s\" test setup hook %s', this.title, handler)\n    this.#hooks.add('setup', handler)\n    return this\n  }\n\n  /**\n   * Register a test teardown function\n   */\n  teardown(handler: TestHooksHandler<Context>): this {\n    debug('registering \"%s\" test teardown hook %s', this.title, handler)\n    this.#hooks.add('teardown', handler)\n    return this\n  }\n\n  /**\n   * Register a cleanup hook from within the test\n   */\n  cleanup(handler: TestHooksCleanupHandler<Context>): this {\n    debug('registering \"%s\" test cleanup function %s', this.title, handler)\n    this.#hooks.add('cleanup', handler)\n    return this\n  }\n\n  /**\n   * Execute test\n   */\n  async exec() {\n    const self = this.constructor as typeof Test\n\n    /**\n     * Return early, if there are pinned test and the current test is not\n     * pinned.\n     *\n     * However, the pinned test check is only applied when there\n     * is no filter on the test title.\n     */\n    if (!this.#refiner.allows(this)) {\n      debug('test \"%s\" skipped by refiner', this.title)\n      return\n    }\n\n    /**\n     * Avoid re-running the same test multiple times\n     */\n    if (this.#executed) {\n      return\n    }\n\n    this.#executed = true\n\n    /**\n     * Do not run tests without executor function\n     */\n    this.#computeisTodo()\n    if (this.options.isTodo) {\n      debug('skipping todo test \"%s\"', this.title)\n      new DummyRunner(this, this.#emitter).run()\n      return\n    }\n\n    /**\n     * Do not run test meant to be skipped\n     */\n    await this.#computeShouldSkip()\n    if (this.options.isSkipped) {\n      debug(\n        'skipping test \"%s\", reason (%s)',\n        this.title,\n        this.options.skipReason || 'Skipped using .skip method'\n      )\n      new DummyRunner(this, this.#emitter).run()\n      return\n    }\n\n    /**\n     * Compute dataset by calling the with method\n     */\n    await this.#computeDataset()\n\n    /**\n     * Run for each row inside dataset\n     */\n    if (Array.isArray(this.dataset) && this.dataset.length) {\n      let index = 0\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      for (let _ of this.dataset) {\n        await this.#computeContext()\n\n        this.#activeRunner = new TestRunner(\n          this,\n          this.#hooks,\n          this.#emitter,\n          {\n            executing: self.executingCallbacks,\n            executed: self.executedCallbacks,\n          },\n          index\n        )\n\n        await this.#activeRunner.run()\n\n        index++\n      }\n\n      this.#activeRunner = undefined\n      return\n    }\n\n    /**\n     * Run when no dataset is used\n     */\n    await this.#computeContext()\n\n    this.#activeRunner = new TestRunner(this, this.#hooks, this.#emitter, {\n      executing: self.executingCallbacks,\n      executed: self.executedCallbacks,\n    })\n\n    await this.#activeRunner.run()\n    this.#activeRunner = undefined\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport retry from 'async-retry'\nimport Hooks from '@poppinss/hooks'\nimport type { Runner } from '@poppinss/hooks/types'\nimport timeSpan, { TimeEndFunction } from 'time-span'\n\nimport debug from '../debug.js'\nimport { Test } from './main.js'\nimport { Emitter } from '../emitter.js'\nimport { interpolate } from '../interpolate.js'\nimport type { TestEndNode, TestHooks, TestHooksData, TestStartNode } from '../types.js'\n\n/**\n * Dummy test runner that just emits the required events\n */\nexport class DummyRunner {\n  #test: Test<any, any>\n  #emitter: Emitter\n\n  constructor(test: Test<any, any>, emitter: Emitter) {\n    this.#test = test\n    this.#emitter = emitter\n  }\n\n  /**\n   * Notify the reporter about the test start\n   */\n  #notifyStart() {\n    const startOptions: TestStartNode = {\n      ...this.#test.options,\n      title: {\n        original: this.#test.options.title,\n        expanded: this.#test.options.title,\n      },\n      isPinned: this.#test.isPinned,\n    }\n    this.#emitter.emit('test:start', startOptions)\n  }\n\n  /**\n   * Notify the reporter about the test start\n   */\n  #notifyEnd() {\n    const endOptions: TestEndNode = {\n      ...this.#test.options,\n      title: {\n        original: this.#test.options.title,\n        expanded: this.#test.options.title,\n      },\n      isPinned: this.#test.isPinned,\n      hasError: false,\n      duration: 0,\n      errors: [],\n    }\n\n    this.#emitter.emit('test:end', endOptions)\n  }\n\n  /**\n   * Run test\n   */\n  run() {\n    this.#notifyStart()\n    this.#notifyEnd()\n  }\n}\n\n/**\n * Run an instance of test\n */\nexport class TestRunner {\n  #emitter: Emitter\n\n  /**\n   * Timeout timer and promise reject method references to\n   * fail the test after timeout. We keep global reference\n   * to allow timeout reset within the test.\n   */\n  #timeout?: {\n    timer: NodeJS.Timeout\n    reject: (error: Error) => void\n  }\n\n  /**\n   * Time tracker to find test duration\n   */\n  #timeTracker?: TimeEndFunction\n\n  /**\n   * Reference to the startup runner\n   */\n  #setupRunner: Runner<TestHooksData<Record<any, any>>[0], TestHooksData<Record<any, any>>[1]>\n\n  /**\n   * Reference to the cleanup runner\n   */\n  #teardownRunner: Runner<TestHooksData<Record<any, any>>[0], TestHooksData<Record<any, any>>[1]>\n\n  /**\n   * Test errors\n   */\n  #errors: TestEndNode['errors'] = []\n\n  /**\n   * Track if test has any errors\n   */\n  #hasError: boolean = false\n\n  /**\n   * Current dataset index for which executing the test\n   */\n  #datasetCurrentIndex: number | undefined\n\n  /**\n   * Callbacks to execute around the test executor\n   */\n  #callbacks: {\n    executing: ((test: Test<any, any>) => void)[]\n    executed: ((test: Test<any, any>, hasError: boolean, errors: TestEndNode['errors']) => void)[]\n  }\n\n  /**\n   * Reference to parent test\n   */\n  #test: Test<any, any>\n\n  /**\n   * Need access to hooks so that we can grab an instance of\n   * \"cleanup\" runner.\n   *\n   * The cleanup runner should be fetched post running the test callback,\n   * since that callback can push hooks to the cleanup event.\n   */\n  #hooks: Hooks<TestHooks<Record<any, any>>>\n\n  constructor(\n    test: Test<any, any>,\n    hooks: Hooks<TestHooks<Record<any, any>>>,\n    emitter: Emitter,\n    callbacks: {\n      executing: ((test: Test<any, any>) => void)[]\n      executed: ((test: Test<any, any>, hasError: boolean, errors: TestEndNode['errors']) => void)[]\n    },\n    datasetCurrentIndex?: number\n  ) {\n    this.#test = test\n    this.#hooks = hooks\n    this.#emitter = emitter\n    this.#callbacks = callbacks\n    this.#datasetCurrentIndex = datasetCurrentIndex\n    this.#setupRunner = hooks.runner('setup')\n    this.#teardownRunner = hooks.runner('teardown')\n  }\n\n  /**\n   * Returns the dataset node for the test events\n   */\n  #getDatasetNode() {\n    if (this.#datasetCurrentIndex !== undefined && this.#test.dataset) {\n      return {\n        dataset: {\n          row: this.#test.dataset[this.#datasetCurrentIndex],\n          index: this.#datasetCurrentIndex,\n          size: this.#test.dataset.length,\n        },\n      }\n    }\n  }\n\n  /**\n   * Get the title node for the test\n   */\n  #getTitle(dataset?: { row: any; index: number }) {\n    const title = this.#test.options.title\n\n    return {\n      original: title,\n      expanded: dataset ? interpolate(title, dataset.row, dataset.index + 1) : title,\n    }\n  }\n\n  /**\n   * Notify the reporter about the test start\n   */\n  #notifyStart() {\n    this.#timeTracker = timeSpan()\n    const dataset = this.#getDatasetNode()\n\n    const startOptions: TestStartNode = {\n      ...this.#test.options,\n      ...dataset,\n      isPinned: this.#test.isPinned,\n      title: this.#getTitle(dataset ? dataset.dataset : undefined),\n    }\n\n    this.#emitter.emit('test:start', startOptions)\n  }\n\n  /**\n   * Notify the reporter about the test start\n   */\n  #notifyEnd() {\n    const dataset = this.#getDatasetNode()\n\n    const endOptions: TestEndNode = {\n      ...this.#test.options,\n      ...dataset,\n      isPinned: this.#test.isPinned,\n      title: this.#getTitle(dataset ? dataset.dataset : undefined),\n      hasError: this.#hasError,\n      errors: this.#errors,\n      retryAttempt: this.#test.options.retryAttempt,\n      duration: this.#timeTracker?.() ?? 0,\n    }\n\n    this.#emitter.emit('test:end', endOptions)\n  }\n\n  /**\n   * Running setup hooks\n   */\n  async #runSetupHooks() {\n    try {\n      debug('running \"%s\" test setup hooks', this.#test.title)\n      await this.#setupRunner.run(this.#test)\n    } catch (error) {\n      debug('test setup hooks failed, test: %s, error: %O', this.#test.title, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'setup', error })\n    }\n  }\n\n  /**\n   * Running teardown hooks\n   */\n  async #runTeardownHooks() {\n    try {\n      debug('running \"%s\" test teardown hooks', this.#test.title)\n      await this.#teardownRunner.run(this.#test)\n    } catch (error) {\n      debug('test teardown hooks failed, test: %s, error: %O', this.#test.title, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'teardown', error })\n    }\n  }\n\n  /**\n   * Running test cleanup functions\n   */\n  async #runTestCleanupFunctions() {\n    const cleanupRunner = this.#hooks.runner('cleanup')\n    this.#hooks.clear('cleanup')\n    try {\n      debug('running \"%s\" test cleanup functions', this.#test.title)\n      await cleanupRunner.runReverse(this.#hasError, this.#test)\n    } catch (error) {\n      debug('test cleanup functions failed, test: %s, error: %O', this.#test.title, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'test:cleanup', error })\n    }\n  }\n\n  /**\n   * Running setup cleanup functions\n   */\n  async #runSetupCleanupFunctions() {\n    try {\n      debug('running \"%s\" test setup cleanup functions', this.#test.title)\n      await this.#setupRunner.cleanup(this.#hasError, this.#test)\n    } catch (error) {\n      debug('test setup cleanup functions failed, test: %s, error: %O', this.#test.title, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'setup:cleanup', error })\n    }\n  }\n\n  /**\n   * Running teardown cleanup functions\n   */\n  async #runTeardownCleanupFunctions() {\n    try {\n      debug('running \"%s\" test teardown cleanup functions', this.#test.title)\n      await this.#teardownRunner.cleanup(this.#hasError, this.#test)\n    } catch (error) {\n      debug('test teardown cleanup functions failed, test: %s, error: %O', this.#test.title, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'teardown:cleanup', error })\n    }\n  }\n\n  /**\n   * Run the test executor. The method takes care of passing\n   * dataset row to the test method\n   */\n  async #runTest(done?: (error?: any) => void) {\n    const datasetRow =\n      this.#datasetCurrentIndex !== undefined && this.#test.dataset\n        ? this.#test.dataset[this.#datasetCurrentIndex]\n        : undefined\n\n    return datasetRow !== undefined\n      ? (this.#test.options.executor as any)(this.#test.context, datasetRow, done)\n      : (this.#test.options.executor as any)(this.#test.context, done)\n  }\n\n  /**\n   * Run the test executor that relies on the done method. The test will\n   * timeout if done isn't called.\n   */\n  #runTestWithDone() {\n    return new Promise<void>((resolve, reject) => {\n      const done = (error?: any) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      }\n\n      debug('running test \"%s\" and waiting for done method call', this.#test.title)\n      this.#runTest(done).catch(reject)\n    })\n  }\n\n  /**\n   * Creates a timeout promise with global timer to reject\n   * the promise after given duration.\n   */\n  #createTimeoutTimer(duration: number) {\n    return new Promise((_, reject) => {\n      debug('wrapping test in timeout timer')\n      this.#timeout = {\n        reject,\n        timer: setTimeout(() => this.#timeout!.reject(new Error('Test timeout')), duration),\n      }\n    })\n  }\n\n  /**\n   * Resets the timeout timer\n   */\n  #resetTimer(duration: number) {\n    if (this.#timeout) {\n      debug('resetting timer')\n      clearTimeout(this.#timeout.timer)\n      this.#timeout.timer = setTimeout(\n        () => this.#timeout!.reject(new Error('Test timeout')),\n        duration\n      )\n    }\n  }\n\n  /**\n   * Clears the timer\n   */\n  #clearTimer() {\n    if (this.#timeout) {\n      debug('clearing timer')\n      clearTimeout(this.#timeout.timer)\n      this.#timeout = undefined\n    }\n  }\n\n  /**\n   * Run the test executor and make sure it times out after the configured\n   * timeout.\n   */\n  async #wrapTestInTimeout() {\n    if (!this.#test.options.timeout) {\n      return this.#test.options.waitsForDone ? this.#runTestWithDone() : this.#runTest()\n    }\n\n    try {\n      await Promise.race([\n        this.#createTimeoutTimer(this.#test.options.timeout),\n        this.#test.options.waitsForDone ? this.#runTestWithDone() : this.#runTest(),\n      ])\n    } finally {\n      this.#clearTimer()\n    }\n  }\n\n  /**\n   * Runs the test with retries in place\n   */\n  #wrapTestInRetries() {\n    if (!this.#test.options.retries) {\n      return this.#wrapTestInTimeout()\n    }\n\n    return retry(\n      (_: unknown, attempt: number) => {\n        this.#test.options.retryAttempt = attempt\n        return this.#wrapTestInTimeout()\n      },\n      { retries: this.#test.options.retries, factor: 1 }\n    )\n  }\n\n  /**\n   * Reset test timeout. The timeout will be removed, if\n   * no duration value is provided\n   */\n  resetTimeout(duration?: number) {\n    if (!duration) {\n      this.#clearTimer()\n    } else {\n      this.#resetTimer(duration)\n    }\n  }\n\n  /**\n   * Run the test\n   */\n  async run() {\n    debug('starting to run \"%s\" test', this.#test.title)\n    this.#notifyStart()\n\n    /**\n     * Run setup hooks and exit early when one of the hooks\n     * fails\n     */\n    await this.#runSetupHooks()\n    if (this.#hasError) {\n      await this.#runSetupCleanupFunctions()\n      this.#notifyEnd()\n      return\n    }\n\n    /**\n     * Run the test executor\n     */\n    try {\n      this.#callbacks.executing.forEach((callback) => callback(this.#test))\n      await this.#wrapTestInRetries()\n    } catch (error) {\n      this.#hasError = true\n      this.#errors.push({ phase: 'test', error })\n    }\n\n    /**\n     * Run dispose callbacks\n     */\n    this.#callbacks.executed.forEach((callback) => {\n      try {\n        callback(this.#test, this.#hasError, this.#errors)\n      } catch (error) {\n        this.#hasError = true\n        this.#errors.push({ phase: 'test', error })\n      }\n    })\n\n    /**\n     * Run test cleanup hooks\n     */\n    await this.#runTestCleanupFunctions()\n\n    /**\n     * Cleanup setup hooks\n     */\n    await this.#runSetupCleanupFunctions()\n\n    /**\n     * Run + cleanup teardown hooks\n     */\n    await this.#runTeardownHooks()\n    await this.#runTeardownCleanupFunctions()\n\n    /**\n     * Notify test end\n     */\n    this.#notifyEnd()\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Parses prop\n */\nfunction parseProp(data: any, key: string) {\n  const tokens = key.split('.')\n  while (tokens.length) {\n    if (data === null || typeof data !== 'object') {\n      return\n    }\n    const token = tokens.shift()!\n    data = Object.hasOwn(data, token) ? data[token] : undefined\n  }\n  return data\n}\n\n/**\n * A simple function interpolate values inside curly braces.\n *\n * @example\n * interpolate('hello { username }', { username: 'virk' })\n */\nexport function interpolate(input: string, data: any, index: number) {\n  return input.replace(/(\\\\)?{(.*?)}/g, (_, escapeChar, key) => {\n    if (escapeChar) {\n      return `{${key}}`\n    }\n\n    key = key.trim()\n    if (key === '$i') {\n      return index\n    }\n\n    if (key === '$self') {\n      return data\n    }\n\n    return parseProp(data, key)\n  })\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport Emittery from 'emittery'\nimport { RunnerEvents } from './types.js'\n\n/**\n * Runner emitter\n */\nexport class Emitter extends Emittery<RunnerEvents> {\n  #errorHandler?: (error: any) => void | Promise<void>\n\n  /**\n   * Define onError handler invoked when `emit` fails\n   */\n  onError(errorHandler: (error: any) => void | Promise<void>) {\n    this.#errorHandler = errorHandler\n  }\n\n  /**\n   * Emit event\n   */\n  async emit<Name extends keyof RunnerEvents>(\n    eventName: Name,\n    eventData?: RunnerEvents[Name],\n    allowMetaEvents?: boolean\n  ): Promise<void> {\n    try {\n      await (super.emit as any)(eventName, eventData!, allowMetaEvents)\n    } catch (error) {\n      if (this.#errorHandler) {\n        await this.#errorHandler(error)\n      } else {\n        throw error\n      }\n    }\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport Hooks from '@poppinss/hooks'\nimport Macroable from '@poppinss/macroable'\n\nimport debug from '../debug.js'\nimport { Test } from '../test/main.js'\nimport { Refiner } from '../refiner.js'\nimport { Emitter } from '../emitter.js'\nimport { GroupRunner } from './runner.js'\nimport type { GroupHooksHandler, TestHooksHandler, GroupOptions, GroupHooks } from '../types.js'\n\n/**\n * Group class exposes an API to group multiple tests together\n * and bulk configure them.\n *\n * NOTE: Nested groups are not supported on purpose.\n *\n * @example\n * const group = new Group('addition', emitter, refiner)\n * const test = new Test('2 + 2 = 4', emitter, refiner)\n *\n * group.add(test)\n * await group.exec()\n */\nexport class Group<Context extends Record<any, any>> extends Macroable {\n  #emitter: Emitter\n  #refiner: Refiner\n\n  /**\n   * Reference to registered hooks\n   */\n  #hooks = new Hooks<GroupHooks<Context>>()\n\n  /**\n   * Callbacks to invoke on each test\n   */\n  #tapsCallbacks: ((test: Test<Context, any>) => void)[] = []\n\n  /**\n   * Properties to configure on every test\n   */\n  #testsTimeout?: number\n  #testsRetries?: number\n  #testSetupHooks: TestHooksHandler<Context>[] = []\n  #testTeardownHooks: TestHooksHandler<Context>[] = []\n\n  options: GroupOptions\n\n  /**\n   * An array of tests registered under the given group\n   */\n  tests: Test<Context, any>[] = []\n\n  /**\n   * Shortcut methods to configure tests\n   */\n  each: {\n    setup: (handler: TestHooksHandler<Context>) => void\n    teardown: (handler: TestHooksHandler<Context>) => void\n    timeout: (timeout: number) => void\n    retry: (retries: number) => void\n    disableTimeout: () => void\n  } = {\n    /**\n     * Define setup hook for all tests inside the group\n     */\n    setup: (handler: TestHooksHandler<Context>) => {\n      this.#testSetupHooks.push(handler)\n    },\n\n    /**\n     * Define teardown hook for all tests inside the group\n     */\n    teardown: (handler: TestHooksHandler<Context>) => {\n      this.#testTeardownHooks.push(handler)\n    },\n\n    /**\n     * Define timeout for all tests inside the group\n     */\n    timeout: (timeout: number) => {\n      this.#testsTimeout = timeout\n    },\n\n    /**\n     * Disable timeout for all tests inside the group\n     */\n    disableTimeout: () => {\n      this.#testsTimeout = 0\n    },\n\n    /**\n     * Define retries for all tests inside the group\n     */\n    retry: (retries: number) => {\n      this.#testsRetries = retries\n    },\n  }\n\n  constructor(\n    public title: string,\n    emitter: Emitter,\n    refiner: Refiner\n  ) {\n    super()\n    this.#emitter = emitter\n    this.#refiner = refiner\n    this.options = {\n      title: this.title,\n      meta: {},\n    }\n  }\n\n  /**\n   * Add a test to the group. Adding a test to the group\n   * mutates the test properties\n   */\n  add(test: Test<Context, any>): this {\n    debug('adding \"%s\" test to \"%s\" group', test.title, this.title)\n\n    /**\n     * Bulk configure\n     */\n    if (this.#testsTimeout !== undefined) {\n      test.timeout(this.#testsTimeout)\n    }\n    if (this.#testsRetries !== undefined) {\n      test.retry(this.#testsRetries)\n    }\n    if (this.#testSetupHooks.length) {\n      this.#testSetupHooks.forEach((handler) => test.setup(handler))\n    }\n    if (this.#testTeardownHooks.length) {\n      this.#testTeardownHooks.forEach((handler) => test.teardown(handler))\n    }\n\n    /**\n     * Invoke tap callback passing test to each callback\n     */\n    this.#tapsCallbacks.forEach((callback) => callback(test))\n\n    this.tests.push(test)\n    return this\n  }\n\n  /**\n   * Tap into each test and configure it\n   */\n  tap(callback: (test: Test<Context, any>) => void): this {\n    this.tests.forEach((test) => callback(test))\n    this.#tapsCallbacks.push(callback)\n    return this\n  }\n\n  /**\n   * Define setup hook for the group\n   */\n  setup(handler: GroupHooksHandler<Context>): this {\n    debug('registering \"%s\" group setup hook %s', this.title, handler)\n    this.#hooks.add('setup', handler)\n    return this\n  }\n\n  /**\n   * Define teardown hook for the group\n   */\n  teardown(handler: GroupHooksHandler<Context>): this {\n    debug('registering \"%s\" group teardown hook %s', this.title, handler)\n    this.#hooks.add('teardown', handler)\n    return this\n  }\n\n  /**\n   * Execute group hooks and tests\n   */\n  async exec() {\n    if (!this.#refiner.allows(this)) {\n      debug('group skipped by refined %s', this.title)\n      return\n    }\n\n    await new GroupRunner(this, this.#hooks, this.#emitter).run()\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport Hooks from '@poppinss/hooks'\nimport { Runner } from '@poppinss/hooks/types'\n\nimport debug from '../debug.js'\nimport { Group } from './main.js'\nimport { Emitter } from '../emitter.js'\nimport type { GroupEndNode, GroupHooks, GroupHooksData, GroupStartNode } from '../types.js'\n\n/**\n * Run all tests for a given group\n */\nexport class GroupRunner {\n  /**\n   * Parent group\n   */\n  #group: Group<any>\n\n  /**\n   * Emitter instance to notify reporters\n   */\n  #emitter: Emitter\n\n  /**\n   * Reference to the startup runner\n   */\n  #setupRunner: Runner<GroupHooksData<Record<any, any>>[0], GroupHooksData<Record<any, any>>[1]>\n\n  /**\n   * Reference to the cleanup runner\n   */\n  #teardownRunner: Runner<GroupHooksData<Record<any, any>>[0], GroupHooksData<Record<any, any>>[1]>\n\n  /**\n   * Test errors\n   */\n  #errors: {\n    phase: 'setup' | 'setup:cleanup' | 'teardown' | 'teardown:cleanup'\n    error: Error\n  }[] = []\n\n  /**\n   * Track if test has any errors\n   */\n  #hasError: boolean = false\n\n  constructor(group: Group<any>, hooks: Hooks<GroupHooks<Record<any, any>>>, emitter: Emitter) {\n    this.#group = group\n    this.#emitter = emitter\n    this.#setupRunner = hooks.runner('setup')\n    this.#teardownRunner = hooks.runner('teardown')\n  }\n\n  /**\n   * Notify the reporter about the group start\n   */\n  #notifyStart() {\n    const startOptions: GroupStartNode = { ...this.#group.options }\n    this.#emitter.emit('group:start', startOptions)\n  }\n\n  /**\n   * Notify the reporter about the group end\n   */\n  #notifyEnd() {\n    const endOptions: GroupEndNode = {\n      ...this.#group.options,\n      hasError: this.#hasError,\n      errors: this.#errors,\n    }\n\n    this.#emitter.emit('group:end', endOptions)\n  }\n\n  /**\n   * Running setup hooks\n   */\n  async #runSetupHooks() {\n    try {\n      debug('running \"%s\" group setup hooks', this.#group.title)\n      await this.#setupRunner.run(this.#group)\n    } catch (error) {\n      debug('group setup hooks failed, group: %s, error: %O', this.#group.title, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'setup', error })\n    }\n  }\n\n  /**\n   * Running teardown hooks\n   */\n  async #runTeardownHooks() {\n    try {\n      debug('running \"%s\" group teardown hooks', this.#group.title)\n      await this.#teardownRunner.run(this.#group)\n    } catch (error) {\n      debug('group teardown hooks failed, group: %s, error: %O', this.#group.title, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'teardown', error })\n    }\n  }\n\n  /**\n   * Running setup cleanup functions\n   */\n  async #runSetupCleanupFunctions() {\n    try {\n      debug('running \"%s\" group setup cleanup functions', this.#group.title)\n      await this.#setupRunner.cleanup(this.#hasError, this.#group)\n    } catch (error) {\n      debug('group setup cleanup function failed, group: %s, error: %O', this.#group.title, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'setup:cleanup', error })\n    }\n  }\n\n  /**\n   * Running teardown cleanup functions\n   */\n  async #runTeardownCleanupFunctions() {\n    try {\n      debug('running \"%s\" group teardown cleanup functions', this.#group.title)\n      await this.#teardownRunner.cleanup(this.#hasError, this.#group)\n    } catch (error) {\n      debug(\n        'group teardown cleanup function failed, group: %s, error: %O',\n        this.#group.title,\n        error\n      )\n\n      this.#hasError = true\n      this.#errors.push({ phase: 'teardown:cleanup', error })\n    }\n  }\n\n  /**\n   * Run the test\n   */\n  async run() {\n    debug('starting to run \"%s\" group', this.#group.title)\n    this.#notifyStart()\n\n    /**\n     * Run setup hooks and exit early when one of the hooks\n     * fails\n     */\n    await this.#runSetupHooks()\n    if (this.#hasError) {\n      await this.#runSetupCleanupFunctions()\n      this.#notifyEnd()\n      return\n    }\n\n    /**\n     * Run the test executor\n     */\n    for (let test of this.#group.tests) {\n      await test.exec()\n    }\n\n    /**\n     * Cleanup setup hooks\n     */\n    await this.#runSetupCleanupFunctions()\n\n    /**\n     * Run + cleanup teardown hooks\n     */\n    await this.#runTeardownHooks()\n    await this.#runTeardownCleanupFunctions()\n\n    /**\n     * Notify test end\n     */\n    this.#notifyEnd()\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Test } from './test/main.js'\nimport { Group } from './group/main.js'\nimport type { FilteringOptions } from './types.js'\n\n/**\n * Exposes the API to refine unwanted tests based upon applied\n * filters.\n *\n * @example\n * const refiner = new Refiner({ tags: ['@slow'] })\n * refiner.allows('tags', ['@slow']) // true\n * refiner.allows('tags', ['@regression']) // false\n *\n * const refiner = new Refiner({ tags: [] })\n * refiner.allows('tags', ['@slow']) // true\n * refiner.allows('tags', ['@regression']) // true\n */\nexport class Refiner {\n  /**\n   * Controls if test tags should match all the defined\n   * tags or not.\n   *\n   * Defaults to false\n   */\n  #shouldMatchAllTags: boolean = false\n\n  /**\n   * A set of pinned tests\n   */\n  #pinnedTests: Set<Test<any, any>> = new Set()\n\n  /**\n   * Available filters\n   */\n  #filters: Required<FilteringOptions> & { negatedTags: string[] } = {\n    tags: [],\n    tests: [],\n    groups: [],\n    negatedTags: [],\n  }\n\n  constructor(filters: FilteringOptions = {}) {\n    if (filters.tags) {\n      this.add('tags', filters.tags)\n    }\n\n    if (filters.tests) {\n      this.add('tests', filters.tests)\n    }\n\n    if (filters.groups) {\n      this.add('groups', filters.groups)\n    }\n  }\n\n  /**\n   * Find if the group is allowed to execute its tests.\n   */\n  #isGroupAllowed(group: Group<any>): boolean {\n    const groupFilters = this.#filters.groups\n\n    /**\n     * Group filters exists and group title is not within the filters\n     * list, then return false right away\n     */\n    if (groupFilters.length && !groupFilters.includes(group.title)) {\n      return false\n    }\n\n    /**\n     * By default the group is not allowed to be executed. However,\n     * we go through all the tests within that group and if\n     * one or more tests are allowed to run, then we will\n     * allow the group to run as well.\n     *\n     * Basically, we are checking the children to find if the group\n     * should run or not.\n     */\n    let allowGroup = false\n    for (let test of group.tests) {\n      allowGroup = this.allows(test)\n      if (allowGroup) {\n        break\n      }\n    }\n\n    return allowGroup\n  }\n\n  /**\n   * Find if the test is allowed to be executed by checking\n   * for the test title filter\n   */\n  #isTestTitleAllowed(test: Test<any, any>): boolean {\n    /**\n     * All tests are allowed, when no filters are applied\n     * on the test title\n     */\n    if (!this.#filters.tests.length) {\n      return true\n    }\n\n    return this.#filters.tests.includes(test.title)\n  }\n\n  /**\n   * Find if test is allowed by the negated tags filter\n   */\n  #allowedByNegatedTags(test: Test<any, any>): boolean {\n    if (!this.#filters.negatedTags.length) {\n      return true\n    }\n\n    /**\n     * There should be zero matching negated tags\n     */\n    return this.#filters.negatedTags.every((tag) => !test.options.tags.includes(tag))\n  }\n\n  /**\n   * Test if the test is allowed by the tags filter\n   */\n  #allowedByTags(test: Test<any, any>): boolean {\n    if (!this.#filters.tags.length) {\n      return true\n    }\n\n    /**\n     * Find one or more matching tags\n     */\n    if (this.#shouldMatchAllTags) {\n      return this.#filters.tags.every((tag) => test.options.tags.includes(tag))\n    }\n    return this.#filters.tags.some((tag) => test.options.tags.includes(tag))\n  }\n\n  /*\n   * Find if the test is allowed to be executed by checking\n   * for the test tags\n   */\n  #areTestTagsAllowed(test: Test<any, any>): boolean {\n    return this.#allowedByTags(test) && this.#allowedByNegatedTags(test)\n  }\n\n  /*\n   * Find if the test is allowed to be executed by checking\n   * for the pinned tests\n   */\n  #isAllowedByPinnedTest(test: Test<any, any>): boolean {\n    /**\n     * All tests are allowed, when no tests are pinned\n     */\n    if (!this.#pinnedTests.size) {\n      return true\n    }\n\n    return this.#pinnedTests.has(test)\n  }\n\n  /**\n   * Enable/disable matching of all tags when filtering tests.\n   * If \"matchAll\" is enabled, the test tags should match\n   * all the user defined tags.\n   *\n   * Otherwise, any one match will pass the filter\n   */\n  matchAllTags(state: boolean): this {\n    this.#shouldMatchAllTags = state\n    return this\n  }\n\n  /**\n   * Pin a test to be executed.\n   */\n  pinTest(test: Test<any, any>): void {\n    this.#pinnedTests.add(test)\n  }\n\n  /**\n   * Find if a test is pinned\n   */\n  isPinned(test: Test<any, any>): boolean {\n    return this.#pinnedTests.has(test)\n  }\n\n  /**\n   * Add a filter\n   */\n  add(layer: 'tests' | 'tags' | 'groups', values: string[]): void {\n    if (layer === 'tags') {\n      values.forEach((tag) => {\n        if (tag.startsWith('!') || tag.startsWith('~')) {\n          this.#filters.negatedTags.push(tag.slice(1))\n        } else {\n          this.#filters.tags.push(tag)\n        }\n      })\n    } else {\n      this.#filters[layer].push(...values)\n    }\n  }\n\n  /**\n   * Check if refiner allows a specific test or group to run by looking\n   * at the applied filters\n   */\n  allows(testOrGroup: Test<any, any> | Group<any>): boolean {\n    if (testOrGroup instanceof Group) {\n      return this.#isGroupAllowed(testOrGroup)\n    }\n\n    /**\n     * Do not run lone tests when group filter is applied. It is responsibility\n     * of the runner to attach groups to tests.\n     */\n    if (this.#filters.groups.length && !testOrGroup.parent) {\n      return false\n    }\n\n    /**\n     * Layer 1\n     */\n    const isTestTitleAllowed = this.#isTestTitleAllowed(testOrGroup)\n    if (!isTestTitleAllowed) {\n      return false\n    }\n\n    /**\n     * Layer 2\n     */\n    const areTestTagsAllowed = this.#areTestTagsAllowed(testOrGroup)\n    if (!areTestTagsAllowed) {\n      return false\n    }\n\n    /**\n     * Layer 3\n     */\n    return this.#isAllowedByPinnedTest(testOrGroup)\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport Hooks from '@poppinss/hooks'\nimport Macroable from '@poppinss/macroable'\n\nimport debug from '../debug.js'\nimport { Test } from '../test/main.js'\nimport { Emitter } from '../emitter.js'\nimport { Refiner } from '../refiner.js'\nimport { Group } from '../group/main.js'\nimport { SuiteRunner } from './runner.js'\nimport type { SuiteHooks, SuiteHooksHandler } from '../types.js'\n\n/**\n * The Suite class exposes the API to run a group of tests\n * or independent tests together as part of a suite.\n *\n * You can think of suites as\n *   - unit tests suite\n *   - e2e tests suites\n *   - and so on\n *\n * @example\n * const suite = new Suite('unit', emitter)\n * const group = new Group('addition', emitter, refiner)\n * const test = new Test('2 + 2 = 4', emitter, refiner)\n *\n * suite.add(group)\n * group.add(test)\n *\n * // Runs all the tests inside the registered group\n * await suite.exec()\n */\nexport class Suite<Context extends Record<any, any>> extends Macroable {\n  #refiner: Refiner\n  #emitter: Emitter\n\n  /**\n   * Reference to registered hooks\n   */\n  #hooks = new Hooks<SuiteHooks<Context>>()\n\n  /**\n   * Callbacks to invoke on each test and group\n   */\n  #configureTestCallbacks: ((test: Test<Context, any>) => void)[] = []\n  #configureGroupCallbacks: ((group: Group<Context>) => void)[] = []\n\n  /**\n   * A collection of tests and groups both\n   */\n  stack: (Test<Context, any> | Group<Context>)[] = []\n\n  constructor(\n    public name: string,\n    emitter: Emitter,\n    refiner: Refiner\n  ) {\n    super()\n    this.#emitter = emitter\n    this.#refiner = refiner\n  }\n\n  /**\n   * Add a test or a group to the execution stack\n   */\n  add(testOrGroup: Test<Context, any> | Group<Context>): this {\n    if (testOrGroup instanceof Group) {\n      this.#configureGroupCallbacks.forEach((callback) => callback(testOrGroup))\n    }\n\n    if (testOrGroup instanceof Test) {\n      this.#configureTestCallbacks.forEach((callback) => callback(testOrGroup))\n    }\n\n    this.stack.push(testOrGroup)\n    return this\n  }\n\n  /**\n   * Tap into each test and configure it\n   */\n  onTest(callback: (test: Test<Context, any>) => void): this {\n    this.stack.forEach((testOrGroup) => {\n      if (testOrGroup instanceof Test) {\n        callback(testOrGroup)\n      }\n    })\n\n    this.#configureTestCallbacks.push(callback)\n    return this\n  }\n\n  /**\n   * Tap into each group and configure it\n   */\n  onGroup(callback: (group: Group<Context>) => void): this {\n    this.stack.forEach((testOrGroup) => {\n      if (testOrGroup instanceof Group) {\n        callback(testOrGroup)\n      }\n    })\n\n    this.#configureGroupCallbacks.push(callback)\n    return this\n  }\n\n  /**\n   * Register a test setup function\n   */\n  setup(handler: SuiteHooksHandler<Context>): this {\n    debug('registering suite setup hook %s', handler)\n    this.#hooks.add('setup', handler)\n    return this\n  }\n\n  /**\n   * Register a test teardown function\n   */\n  teardown(handler: SuiteHooksHandler<Context>): this {\n    debug('registering suite teardown hook %s', handler)\n    this.#hooks.add('teardown', handler)\n    return this\n  }\n\n  /**\n   * Execute suite groups, tests and hooks\n   */\n  async exec() {\n    /**\n     * By default a suite is not allowed to be executed. However, we go\n     * through all the tests/ groups within the suite  and if one\n     * or more tests/groups are allowed to run, then we will\n     * allow the suite to run as well.\n     *\n     * Basically, we are checking the children to find if the suite\n     * should run or not.\n     */\n    let allowSuite = false\n    for (let item of this.stack) {\n      allowSuite = this.#refiner.allows(item)\n      if (allowSuite) {\n        break\n      }\n    }\n\n    if (!allowSuite) {\n      debug('suite disabled by refiner %s', this.name)\n      return\n    }\n\n    await new SuiteRunner(this, this.#hooks, this.#emitter).run()\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport Hooks from '@poppinss/hooks'\nimport { Runner } from '@poppinss/hooks/types'\n\nimport debug from '../debug.js'\nimport { Suite } from './main.js'\nimport { Emitter } from '../emitter.js'\nimport type { SuiteEndNode, SuiteHooks, SuiteHooksData, SuiteStartNode } from '../types.js'\n\n/**\n * Run all groups or tests inside the suite stack\n */\nexport class SuiteRunner {\n  #emitter: Emitter\n\n  /**\n   * Parent suite reference\n   */\n  #suite: Suite<any>\n\n  /**\n   * Reference to the startup runner\n   */\n  #setupRunner: Runner<SuiteHooksData<Record<any, any>>[0], SuiteHooksData<Record<any, any>>[1]>\n\n  /**\n   * Reference to the cleanup runner\n   */\n  #teardownRunner: Runner<SuiteHooksData<Record<any, any>>[0], SuiteHooksData<Record<any, any>>[1]>\n\n  /**\n   * Test errors\n   */\n  #errors: {\n    phase: 'setup' | 'setup:cleanup' | 'teardown' | 'teardown:cleanup'\n    error: Error\n  }[] = []\n\n  /**\n   * Track if test has any errors\n   */\n  #hasError: boolean = false\n\n  constructor(suite: Suite<any>, hooks: Hooks<SuiteHooks<Record<any, any>>>, emitter: Emitter) {\n    this.#suite = suite\n    this.#emitter = emitter\n\n    this.#setupRunner = hooks.runner('setup')\n    this.#teardownRunner = hooks.runner('teardown')\n  }\n\n  /**\n   * Notify the reporter about the suite start\n   */\n  #notifyStart() {\n    const startOptions: SuiteStartNode = { name: this.#suite.name }\n    this.#emitter.emit('suite:start', startOptions)\n  }\n\n  /**\n   * Notify the reporter about the suite end\n   */\n  #notifyEnd() {\n    const endOptions: SuiteEndNode = {\n      name: this.#suite.name,\n      hasError: this.#hasError,\n      errors: this.#errors,\n    }\n\n    this.#emitter.emit('suite:end', endOptions)\n  }\n\n  /**\n   * Running setup hooks\n   */\n  async #runSetupHooks() {\n    debug('running \"%s\" suite setup hooks', this.#suite.name)\n    try {\n      await this.#setupRunner.run(this.#suite)\n    } catch (error) {\n      debug('suite setup hooks failed, suite: %s, error: %O', this.#suite.name, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'setup', error })\n    }\n  }\n\n  /**\n   * Running teardown hooks\n   */\n  async #runTeardownHooks() {\n    debug('running \"%s\" suite teardown hooks', this.#suite.name)\n    try {\n      await this.#teardownRunner.run(this.#suite)\n    } catch (error) {\n      debug('suite teardown hooks failed, suite: %s, error: %O', this.#suite.name, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'teardown', error })\n    }\n  }\n\n  /**\n   * Running setup cleanup functions\n   */\n  async #runSetupCleanupFunctions() {\n    debug('running \"%s\" suite setup cleanup functions', this.#suite.name)\n    try {\n      await this.#setupRunner.cleanup(this.#hasError, this.#suite)\n    } catch (error) {\n      debug('suite setup cleanup functions failed, suite: %s, error: %O', this.#suite.name, error)\n      this.#hasError = true\n      this.#errors.push({ phase: 'setup:cleanup', error })\n    }\n  }\n\n  /**\n   * Running teardown cleanup functions\n   */\n  async #runTeardownCleanupFunctions() {\n    debug('running \"%s\" suite teardown cleanup functions', this.#suite.name)\n    try {\n      await this.#teardownRunner.cleanup(this.#hasError, this.#suite)\n    } catch (error) {\n      debug(\n        'suite teardown cleanup functions failed, suite: %s, error: %O',\n        this.#suite.name,\n        error\n      )\n      this.#hasError = true\n      this.#errors.push({ phase: 'teardown:cleanup', error })\n    }\n  }\n\n  /**\n   * Run the test\n   */\n  async run() {\n    debug('starting to run \"%s\" suite', this.#suite.name)\n    this.#notifyStart()\n\n    /**\n     * Run setup hooks and exit early when one of the hooks\n     * fails\n     */\n    await this.#runSetupHooks()\n    if (this.#hasError) {\n      await this.#runSetupCleanupFunctions()\n      this.#notifyEnd()\n      return\n    }\n\n    /**\n     * Run the test executor\n     */\n    for (let groupOrTest of this.#suite.stack) {\n      await groupOrTest.exec()\n    }\n\n    /**\n     * Cleanup setup hooks\n     */\n    await this.#runSetupCleanupFunctions()\n\n    /**\n     * Run + cleanup teardown hooks\n     */\n    await this.#runTeardownHooks()\n    await this.#runTeardownCleanupFunctions()\n\n    /**\n     * Notify test end\n     */\n    this.#notifyEnd()\n  }\n}\n","/*\n * @japa/core\n *\n * (c) Japa\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { inspect } from 'node:util'\nimport Macroable from '@poppinss/macroable'\n\n/**\n * A fresh copy of test context is shared with all the tests\n */\nexport class TestContext extends Macroable {\n  [inspect.custom]() {\n    return inspect(this, { showHidden: false, depth: 1, colors: true, customInspect: false })\n  }\n}\n"],"mappings":"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","names":["Macroable","timeSpan","timeSpan","Macroable","Hooks","Macroable","Macroable","Hooks","Hooks","Macroable","Macroable","Hooks","Macroable"]}