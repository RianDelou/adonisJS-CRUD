{"version":3,"sources":["../src/drivers/scrypt.ts"],"sourcesContent":["/*\n * @adonisjs/hash\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { safeEqual } from '@poppinss/utils'\n\nimport { PhcFormatter } from '../phc_formatter.js'\nimport type { ScryptConfig, HashDriverContract } from '../types.js'\nimport { randomBytesAsync, RangeValidator, scryptAsync, MAX_UINT32 } from '../helpers.js'\n\n/**\n * Hash driver built on top of \"scrypt\" hash algorigthm. Under the hood\n * we make use of the Node.js crypto module\n *\n * The Scrypt implementation uses the PHC formatting for creating\n * and verifying hashes.\n *\n * ```ts\n * const scrypt = new Scrypt({})\n *\n * await scrypt.make('secret')\n * // $scrypt$n=16384,r=8,p=1$iILKD1gVSx6bqualYqyLBQ$DNzIISdmTQS6sFdQ1tJ3UCZ7Uun4uGHNjj0x8FHOqB0pf2LYsu9Xaj5MFhHg21qBz8l5q/oxpeV+ZkgTAj+OzQ\n * ```\n */\nexport class Scrypt implements HashDriverContract {\n  /**\n   * Config with defaults merged\n   */\n  #config: Required<ScryptConfig>\n\n  /**\n   * Formatter to serialize and deserialize phc string\n   */\n  #phcFormatter = new PhcFormatter<{\n    n: number\n    r: number\n    p: number\n  }>()\n\n  constructor(config: ScryptConfig) {\n    this.#config = {\n      cost: 16384,\n      blockSize: 8,\n      parallelization: 1,\n      saltSize: 16,\n      keyLength: 64,\n      maxMemory: 32 * 1024 * 1024,\n      ...config,\n    }\n\n    this.#validateConfig()\n  }\n\n  /**\n   * Validate config\n   */\n  #validateConfig() {\n    RangeValidator.validate('blockSize', this.#config.blockSize, [1, MAX_UINT32])\n    RangeValidator.validate('cost', this.#config.cost, [2, MAX_UINT32])\n    RangeValidator.validate('parallelization', this.#config.parallelization, [\n      1,\n      Math.floor(((Math.pow(2, 32) - 1) * 32) / (128 * this.#config.blockSize)),\n    ])\n\n    RangeValidator.validate('saltSize', this.#config.saltSize, [8, 1024])\n    RangeValidator.validate('keyLength', this.#config.keyLength, [64, 128])\n    RangeValidator.validate('maxMemory', this.#config.maxMemory, [\n      128 * this.#config.cost * this.#config.blockSize + 1,\n      MAX_UINT32,\n    ])\n\n    Object.freeze(this.#config)\n  }\n\n  /**\n   * Validate phc hash string\n   */\n  #validatePhcString(phcString: string) {\n    const phcNode = this.#phcFormatter.deserialize(phcString)\n\n    /**\n     * Validate top level properties to exist\n     */\n    if (phcNode.id !== 'scrypt') {\n      throw new TypeError(`Invalid \"id\" found in the phc string`)\n    }\n    if (!phcNode.params) {\n      throw new TypeError(`No \"params\" found in the phc string`)\n    }\n    if (!phcNode.salt) {\n      throw new TypeError(`No \"salt\" found in the phc string`)\n    }\n    if (!phcNode.hash) {\n      throw new TypeError(`No \"hash\" found in the phc string`)\n    }\n    RangeValidator.validate('hash.byteLength', phcNode.hash.byteLength, [64, 128])\n    RangeValidator.validate('salt.byteLength', phcNode.salt.byteLength, [8, 1024])\n\n    /**\n     * blockSize\n     */\n    RangeValidator.validate('r', phcNode.params.r, [1, MAX_UINT32])\n\n    /**\n     * Cost\n     */\n    RangeValidator.validate('n', phcNode.params.n, [1, MAX_UINT32])\n\n    /**\n     * Parallelization\n     */\n    RangeValidator.validate('p', phcNode.params.p, [\n      1,\n      Math.floor(((Math.pow(2, 32) - 1) * 32) / (128 * phcNode.params.r)),\n    ])\n\n    return {\n      id: phcNode.id,\n      hash: phcNode.hash,\n      salt: phcNode.salt,\n      params: {\n        r: phcNode.params.r,\n        n: phcNode.params.n,\n        p: phcNode.params.p,\n      },\n    }\n  }\n\n  /**\n   * Check if the value is a valid hash. This method just checks\n   * for the formatting of the hash.\n   *\n   * ```ts\n   * scrypt.isValidHash('hello world') // false\n   * scrypt.isValidHash('$scrypt$n=16384,r=8,p=1$iILKD1gVSx6bqualYqyLBQ$DNzIISdmTQS6sFdQ1tJ3UCZ7Uun4uGHNjj0x8FHOqB0pf2LYsu9Xaj5MFhHg21qBz8l5q/oxpeV+ZkgTAj+OzQ')\n   * ```\n   */\n  isValidHash(value: string): boolean {\n    try {\n      this.#validatePhcString(value)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Hash a plain text value\n   *\n   * ```ts\n   * const hash = await scrypt.make('password')\n   * ```\n   */\n  async make(value: string) {\n    const salt = await randomBytesAsync(this.#config.saltSize)\n\n    /**\n     * Generate hash\n     */\n    const hash = await scryptAsync(value, salt, this.#config.keyLength, {\n      cost: this.#config.cost,\n      blockSize: this.#config.blockSize,\n      parallelization: this.#config.parallelization,\n      maxmem: this.#config.maxMemory,\n    })\n\n    /**\n     * Serialize hash\n     */\n    return this.#phcFormatter.serialize(salt, hash, {\n      id: 'scrypt',\n      params: {\n        n: this.#config.cost,\n        r: this.#config.blockSize,\n        p: this.#config.parallelization,\n      },\n    })\n  }\n\n  /**\n   * Verify the plain text value against an existing hash\n   *\n   * ```ts\n   * if (await scrypt.verify(hash, plainText)) {\n   *\n   * }\n   * ```\n   */\n  async verify(hashedValue: string, plainValue: string): Promise<boolean> {\n    try {\n      /**\n       * De-serialize hash and ensure all Phc string properties\n       * to exist.\n       */\n      const phcNode = this.#validatePhcString(hashedValue)\n\n      /**\n       * Generate a new hash with the same properties\n       * as the existing hash\n       */\n      const newHash = await scryptAsync(plainValue, phcNode.salt, phcNode.hash.byteLength, {\n        cost: phcNode.params.n,\n        blockSize: phcNode.params.r,\n        parallelization: phcNode.params.p,\n        maxmem: this.#config.maxMemory,\n      })\n\n      /**\n       * Ensure both are equal\n       */\n      return safeEqual(newHash, phcNode.hash)\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Find if the hash value needs a rehash or not. The rehash is\n   * required when.\n   *\n   * 1. The cost value is changed\n   * 2. The blockSize value is changed\n   * 3. The parallelization value is changed\n   * 4. The provided hash has not been hashed with scrypt\n   *\n   * ```ts\n   * const isValid = await scrypt.verify(hash, plainText)\n   *\n   * // Plain password is valid and hash needs a rehash\n   * if (isValid && await scrypt.needsReHash(hash)) {\n   *   const newHash = await scrypt.make(plainText)\n   * }\n   * ```\n   */\n  needsReHash(value: string): boolean {\n    const phcNode = this.#phcFormatter.deserialize(value)\n    if (phcNode.id !== 'scrypt') {\n      return true\n    }\n\n    /**\n     * Make sure all the encoded params are same as the config.\n     * Otherwise a re-hash is needed\n     */\n    if (!phcNode.params) {\n      return true\n    }\n    if (phcNode.params.n !== this.#config.cost) {\n      return true\n    }\n    if (phcNode.params.r !== this.#config.blockSize) {\n      return true\n    }\n    if (phcNode.params.p !== this.#config.parallelization) {\n      return true\n    }\n\n    return false\n  }\n}\n"],"mappings":"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","names":[]}