{"version":3,"sources":["../../../src/drivers/argon.ts"],"sourcesContent":["/*\n * @adonisjs/hash\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type argon2 from 'argon2'\nimport { safeEqual } from '@poppinss/utils'\n\nimport { PhcFormatter } from '../phc_formatter.js'\nimport {\n  MAX_UINT24,\n  MAX_UINT32,\n  EnumValidator,\n  RangeValidator,\n  randomBytesAsync,\n} from '../helpers.js'\nimport type { ArgonConfig, ArgonVariants, HashDriverContract } from '../types.js'\n\n/**\n * Hash driver built on top of \"argon2\" hash algorigthm. Under the hood\n * we make use of the \"argon2\" npm package.\n *\n * The Argon implementation uses the PHC formatting for creating\n * and verifying hashes.\n *\n * ```ts\n * const argon = new Argon({})\n *\n * await argon.make('secret')\n * // $argon2id$v=19$t=3,m=4096,p=1$drxJBWzWahR5tMubp+a1Sw$L/Oh2uw6QKW77i/KQ8eGuOt3ui52hEmmKlu1KBVBxiM\n * ```\n */\nexport class Argon implements HashDriverContract {\n  /**\n   * Lazily loaded argon2 binding. Since it is a peer dependency\n   * we cannot import it at top level\n   */\n  #binding?: typeof argon2\n\n  /**\n   * Config with defaults merged\n   */\n  #config: Required<ArgonConfig>\n\n  /**\n   * Formatter to serialize and deserialize phc string\n   */\n  #phcFormatter = new PhcFormatter<{ t: number; m: number; p: number }>()\n\n  /**\n   * Supported variants\n   */\n  #variants: { [K in ArgonVariants]: 0 | 1 | 2 } = {\n    i: 0,\n    d: 1,\n    id: 2,\n  }\n\n  /**\n   * A list of supported argon ids\n   */\n  #ids = ['argon2d', 'argon2i', 'argon2id']\n\n  constructor(config: ArgonConfig) {\n    this.#config = {\n      version: 0x13,\n      variant: 'id',\n      iterations: 3,\n      memory: 65536,\n      parallelism: 4,\n      saltSize: 16,\n      hashLength: 32,\n      ...config,\n    }\n\n    this.#validateConfig()\n  }\n\n  /**\n   * Dynamically importing underlying binding\n   */\n  async #importBinding() {\n    if (this.#binding) {\n      return this.#binding\n    }\n\n    this.#binding = await import('argon2')\n    return this.#binding\n  }\n\n  /**\n   * Validate configuration options\n   */\n  #validateConfig() {\n    RangeValidator.validate('iterations', this.#config.iterations, [2, MAX_UINT32])\n    RangeValidator.validate('parallelism', this.#config.parallelism, [1, MAX_UINT24])\n    RangeValidator.validate('memory', this.#config.memory, [\n      8 * this.#config.parallelism,\n      MAX_UINT32,\n    ])\n\n    EnumValidator.validate('variant', this.#config.variant, Object.keys(this.#variants))\n    RangeValidator.validate('saltSize', this.#config.saltSize, [8, 1024])\n    RangeValidator.validate('hashLength', this.#config.hashLength, [4, MAX_UINT32])\n    EnumValidator.validate('version', this.#config.version, [0x10, 0x13])\n\n    Object.freeze(this.#config)\n  }\n\n  /**\n   * Validate phc hash string\n   */\n  #validatePhcString(phcString: string) {\n    const phcNode = this.#phcFormatter.deserialize(phcString)\n\n    /**\n     * Old argon strings without version\n     */\n    if (!phcNode.version) {\n      phcNode.version = 0x10\n    }\n\n    /**\n     * Validate top level properties to exist\n     */\n    if (!phcNode.params) {\n      throw new TypeError(`No \"params\" found in the phc string`)\n    }\n    if (!phcNode.salt) {\n      throw new TypeError(`No \"salt\" found in the phc string`)\n    }\n    if (!phcNode.hash) {\n      throw new TypeError(`No \"hash\" found in the phc string`)\n    }\n    RangeValidator.validate('salt.byteLength', phcNode.salt.byteLength, [8, 1024])\n    RangeValidator.validate('hash.byteLength', phcNode.hash.byteLength, [4, MAX_UINT32])\n\n    /**\n     * Validate id\n     */\n    EnumValidator.validate('id', phcNode.id, this.#ids)\n\n    /**\n     * Validate variant and extract it\n     */\n    const variant = phcNode.id.split('argon2')[1] as ArgonVariants\n    EnumValidator.validate('variant', variant, Object.keys(this.#variants))\n\n    /**\n     * Validate rest of the properties\n     */\n    EnumValidator.validate('version', phcNode.version, [0x10, 0x13])\n    RangeValidator.validate('t', phcNode.params.t, [1, MAX_UINT32])\n    RangeValidator.validate('p', phcNode.params.p, [1, MAX_UINT24])\n    RangeValidator.validate('m', phcNode.params.m, [8 * phcNode.params.p, MAX_UINT32])\n\n    return {\n      id: phcNode.id,\n      version: phcNode.version!,\n      hash: phcNode.hash,\n      salt: phcNode.salt,\n      params: {\n        t: phcNode.params.t,\n        m: phcNode.params.m,\n        p: phcNode.params.p,\n      },\n      variant: variant,\n    }\n  }\n\n  /**\n   * Check if the value is a valid hash. This method just checks\n   * for the formatting of the hash.\n   *\n   * ```ts\n   * argon.isValidHash('hello world') // false\n   * argon.isValidHash('$argon2id$v=19$t=3,m=4096,p=1$drxJBWzWahR5tMubp+a1Sw$L/Oh2uw6QKW77i/KQ8eGuOt3ui52hEmmKlu1KBVBxiM')\n   * ```\n   */\n  isValidHash(value: string): boolean {\n    try {\n      this.#validatePhcString(value)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Hash a plain text value\n   *\n   * ```ts\n   * const hash = await argon.make('password')\n   * ```\n   */\n  async make(value: string) {\n    const driver = await this.#importBinding()\n    const salt = await randomBytesAsync(this.#config.saltSize)\n\n    /**\n     * Generate hash\n     */\n    const hash = await driver.hash(value, {\n      salt,\n      version: this.#config.version,\n      type: this.#variants[this.#config.variant],\n      timeCost: this.#config.iterations,\n      memoryCost: this.#config.memory,\n      parallelism: this.#config.parallelism,\n      hashLength: this.#config.hashLength,\n      raw: true,\n    })\n\n    /**\n     * Serialize hash\n     */\n    return this.#phcFormatter.serialize(salt, hash, {\n      id: `argon2${this.#config.variant}`,\n      version: this.#config.version,\n      params: {\n        t: this.#config.iterations,\n        m: this.#config.memory,\n        p: this.#config.parallelism,\n      },\n    })\n  }\n\n  /**\n   * Verify the plain text value against an existing hash\n   *\n   * ```ts\n   * if (await argon.verify(hash, plainText)) {\n   *\n   * }\n   * ```\n   */\n  async verify(hashedValue: string, plainValue: string): Promise<boolean> {\n    const driver = await this.#importBinding()\n\n    try {\n      /**\n       * De-serialize hash and ensure all Phc string properties\n       * to exist.\n       */\n      const phcNode = this.#validatePhcString(hashedValue)\n\n      /**\n       * Generate a new hash with the same properties\n       * as the existing hash\n       */\n      const newHash = await driver.hash(plainValue, {\n        salt: phcNode.salt,\n        version: phcNode.version,\n        type: this.#variants[phcNode.variant],\n        timeCost: phcNode.params.t,\n        memoryCost: phcNode.params.m,\n        parallelism: phcNode.params.p,\n        hashLength: phcNode.hash.byteLength,\n        raw: true,\n      })\n\n      /**\n       * Ensure both are equal\n       */\n      return safeEqual(newHash, phcNode.hash)\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Find if the hash value needs a rehash or not. The rehash is\n   * required when.\n   *\n   * 1. The argon2 version is changed\n   * 2. Number of iterations are changed\n   * 3. The memory value is changed\n   * 4. The parellelism value is changed\n   * 5. The argon variant is changed\n   * 6. The provided hash has not been hashed with argon\n   *\n   * ```ts\n   * const isValid = await argon.verify(hash, plainText)\n   *\n   * // Plain password is valid and hash needs a rehash\n   * if (isValid && await argon.needsReHash(hash)) {\n   *   const newHash = await argon.make(plainText)\n   * }\n   * ```\n   */\n  needsReHash(value: string): boolean {\n    const phcNode = this.#phcFormatter.deserialize(value)\n    if (!this.#ids.includes(phcNode.id)) {\n      return true\n    }\n\n    /**\n     * If config version is separate from hash version, then a\n     * re-hash is needed\n     */\n    if (phcNode.version !== this.#config.version) {\n      return true\n    }\n\n    /**\n     * If config variant is not same as the hash variant, then a\n     * re-hash is needed\n     */\n    if (phcNode.id !== `argon2${this.#config.variant}`) {\n      return true\n    }\n\n    /**\n     * Make sure all the encoded params are same as the config.\n     * Otherwise a re-hash is needed\n     */\n    if (!phcNode.params) {\n      return true\n    }\n    if (phcNode.params.m !== this.#config.memory) {\n      return true\n    }\n    if (phcNode.params.t !== this.#config.iterations) {\n      return true\n    }\n    if (phcNode.params.p !== this.#config.parallelism) {\n      return true\n    }\n\n    return false\n  }\n}\n"],"mappings":"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","names":[]}