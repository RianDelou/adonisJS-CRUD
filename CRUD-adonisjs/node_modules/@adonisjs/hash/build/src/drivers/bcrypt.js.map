{"version":3,"sources":["../../../src/legacy/bcrypt_base64.cjs","../../../src/drivers/bcrypt.ts"],"sourcesContent":["/* eslint-disable capitalized-comments,unicorn/number-literal-case,unicorn/no-abusive-eslint-disable */\n\n/**\n * Bcrypt does not use standard base64 encoding.\n * https://hackernoon.com/the-bcrypt-protocol-is-kind-of-a-mess-4aace5eb31bd\n */\n\n/**\n * bcrypt's own non-standard base64 dictionary.\n **/\nconst BASE64_CODE = './ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('')\n\n/* eslint-disable prettier/prettier */\nconst BASE64_INDEX = [\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 54,\n  55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n  12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1, 28, 29,\n  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n  -1, -1, -1, -1, -1,\n]\n/* eslint-enable prettier/prettier */\n\n/**\n * Encodes a Buffer to base64 using the bcrypt's base64 dictionary.\n * @param {Buffer} buff Buffer to encode.\n * @returns {string} The buffer encoded as a string.\n */\nfunction encode(buff) {\n  const len = buff.byteLength\n  let off = 0\n  const stra = []\n\n  while (off < len) {\n    let c1 = buff[off++] & 0xff\n    stra.push(BASE64_CODE[(c1 >> 2) & 0x3f])\n    c1 = (c1 & 0x03) << 4\n    if (off >= len) {\n      stra.push(BASE64_CODE[c1 & 0x3f])\n      break\n    }\n    let c2 = buff[off++] & 0xff\n    c1 |= (c2 >> 4) & 0x0f\n    stra.push(BASE64_CODE[c1 & 0x3f])\n    c1 = (c2 & 0x0f) << 2\n    if (off >= len) {\n      stra.push(BASE64_CODE[c1 & 0x3f])\n      break\n    }\n    c2 = buff[off++] & 0xff\n    c1 |= (c2 >> 6) & 0x03\n    stra.push(BASE64_CODE[c1 & 0x3f])\n    stra.push(BASE64_CODE[c2 & 0x3f])\n  }\n  return stra.join('')\n}\n\n/**\n * Decodes a base64 encoded string using the bcrypt's base64 dictionary.\n * @param {string} str String to decode.\n * @returns {Buffer} The string decoded as a Buffer.\n * @inner\n */\nfunction decode(str) {\n  let off = 0\n  let olen = 0\n  const slen = str.length\n  const stra = []\n  const len = str.length\n\n  while (off < slen - 1 && olen < len) {\n    let code = str.charCodeAt(off++)\n    const c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1\n    code = str.charCodeAt(off++)\n    const c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1\n    if (c1 === -1 || c2 === -1) break\n    let o = (c1 << 2) >>> 0\n    o |= (c2 & 0x30) >> 4\n    stra.push(String.fromCharCode(o))\n    if (++olen >= len || off >= slen) break\n    code = str.charCodeAt(off++)\n    const c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1\n    if (c3 === -1) break\n    o = ((c2 & 0x0f) << 4) >>> 0\n    o |= (c3 & 0x3c) >> 2\n    stra.push(String.fromCharCode(o))\n    if (++olen >= len || off >= slen) break\n    code = str.charCodeAt(off++)\n    const c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1\n    o = ((c3 & 0x03) << 6) >>> 0\n    o |= c4\n    stra.push(String.fromCharCode(o))\n    ++olen\n  }\n  const buffa = []\n  for (off = 0; off < olen; off++) buffa.push(stra[off].charCodeAt(0))\n  return Buffer.from(buffa)\n}\n\nmodule.exports = {\n  encode,\n  decode,\n}\n","/*\n * @adonisjs/hash\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport * as bcryptBase64 from '../legacy/bcrypt_base64.cjs'\n\nimport type bcrypt from 'bcrypt'\nimport { safeEqual } from '@poppinss/utils'\nimport { PhcFormatter } from '../phc_formatter.js'\nimport type { HashDriverContract, BcryptConfig } from '../types.js'\nimport { EnumValidator, randomBytesAsync, RangeValidator } from '../helpers.js'\n\n/**\n * Hash driver built on top of \"bcrypt\" hash algorigthm. Under the hood\n * we make use of the \"bcrypt\" npm package.\n *\n * The Bcrypt implementation uses the PHC formatting for creating\n * and verifying hashes.\n *\n * ```ts\n * const bcrypt = new Bcrypt({})\n *\n * await bcrypt.make('secret')\n * // $bcrypt$v=98$r=10$Jtxi46WJ26OQ0khsYLLlnw$knXGfuRFsSjXdj88JydPOnUIglvm1S8\n * ```\n */\nexport class Bcrypt implements HashDriverContract {\n  /**\n   * Lazily loaded bcrypt binding. Since it is a peer dependency\n   * we cannot import it at top level\n   */\n  #binding?: typeof bcrypt\n\n  /**\n   * Config with defaults merged\n   */\n  #config: Required<BcryptConfig>\n\n  /**\n   * Formatter to serialize and deserialize phc string\n   */\n  #phcFormatter = new PhcFormatter<{ r: number }>()\n\n  constructor(config: BcryptConfig) {\n    this.#config = {\n      rounds: 10,\n      saltSize: 16,\n      version: 0x62,\n      ...config,\n    }\n\n    this.#validateConfig()\n  }\n\n  /**\n   * Dynamically importing underlying binding\n   */\n  async #importBinding() {\n    if (this.#binding) {\n      return this.#binding\n    }\n\n    this.#binding = await import('bcrypt')\n    return this.#binding\n  }\n\n  /**\n   * Generates salt for bcrypt\n   */\n  #generateBcryptSalt(salt: Buffer, version: number, rounds: number) {\n    const bcryptVersionCharCode = String.fromCharCode(version)\n    const paddedRounds = rounds > 9 ? `${rounds}` : `0${rounds}`\n    return `$2${bcryptVersionCharCode}$${paddedRounds}$${bcryptBase64.encode(salt)}`\n  }\n\n  /**\n   * Validate config\n   */\n  #validateConfig() {\n    RangeValidator.validate('rounds', this.#config.rounds, [4, 31])\n    RangeValidator.validate('saltSize', this.#config.saltSize, [8, 1024])\n    EnumValidator.validate('version', this.#config.version, [0x61, 0x62])\n    Object.freeze(this.#config)\n  }\n\n  /**\n   * Validate phc hash string\n   */\n  #validatePhcString(phcString: string) {\n    const phcNode = this.#phcFormatter.deserialize(phcString)\n\n    /**\n     * Old bcrypt strings without version\n     */\n    if (!phcNode.version) {\n      phcNode.version = 0x61\n    }\n\n    /**\n     * Validate top level properties to exist\n     */\n    if (phcNode.id !== 'bcrypt') {\n      throw new TypeError(`Invalid \"id\" found in the phc string`)\n    }\n    if (!phcNode.params) {\n      throw new TypeError(`No \"params\" found in the phc string`)\n    }\n    if (!phcNode.salt) {\n      throw new TypeError(`No \"salt\" found in the phc string`)\n    }\n    if (!phcNode.hash) {\n      throw new TypeError(`No \"hash\" found in the phc string`)\n    }\n    if (!phcNode.hash.byteLength) {\n      throw new TypeError(`No \"hash\" found in the phc string`)\n    }\n    RangeValidator.validate('salt.byteLength', phcNode.salt.byteLength, [8, 1024])\n\n    /**\n     * Validate rest of the properties\n     */\n    EnumValidator.validate('version', phcNode.version, [0x61, 0x62])\n    RangeValidator.validate('r', phcNode.params.r, [4, 31])\n\n    return {\n      id: phcNode.id,\n      version: phcNode.version!,\n      hash: phcNode.hash,\n      salt: phcNode.salt,\n      params: {\n        r: phcNode.params.r,\n      },\n    }\n  }\n\n  /**\n   * Check if the value is a valid hash. This method just checks\n   * for the formatting of the hash.\n   *\n   * ```ts\n   * bcrypt.isValidHash('hello world') // false\n   * bcrypt.isValidHash('$bcrypt$v=98$r=10$Jtxi46WJ26OQ0khsYLLlnw$knXGfuRFsSjXdj88JydPOnUIglvm1S8')\n   * ```\n   */\n  isValidHash(value: string): boolean {\n    try {\n      this.#validatePhcString(value)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Hash a plain text value\n   *\n   * ```ts\n   * const hash = await bcrypt.make('password')\n   * ```\n   */\n  async make(value: string) {\n    const driver = await this.#importBinding()\n\n    /**\n     * Generate salt including bcrypt formatted salt\n     */\n    const salt = await randomBytesAsync(this.#config.saltSize)\n    const bcryptSalt = this.#generateBcryptSalt(salt, this.#config.version, this.#config.rounds)\n\n    /**\n     * Generate hash\n     */\n    const bcryptHash = await driver.hash(value, bcryptSalt)\n    const hash = bcryptBase64.decode(bcryptHash.split(bcryptSalt)[1])\n\n    return this.#phcFormatter.serialize(salt, hash, {\n      id: 'bcrypt',\n      version: this.#config.version,\n      params: {\n        r: this.#config.rounds,\n      },\n    })\n  }\n\n  /**\n   * Verify the plain text value against an existing hash\n   *\n   * ```ts\n   * if (await bcrypt.verify(hash, plainText)) {\n   *\n   * }\n   * ```\n   */\n  async verify(hashedValue: string, plainValue: string): Promise<boolean> {\n    const driver = await this.#importBinding()\n\n    try {\n      if (hashedValue.startsWith('$2b') || hashedValue.startsWith('$2a')) {\n        return await driver.compare(plainValue, hashedValue)\n      }\n\n      /**\n       * De-serialize hash and ensure all Phc string properties\n       * to exist.\n       */\n      const phcNode = this.#validatePhcString(hashedValue)\n      const bcryptSalt = this.#generateBcryptSalt(phcNode.salt, phcNode.version, phcNode.params.r)\n\n      const bcryptHash = await driver.hash(plainValue, bcryptSalt)\n      const hash = bcryptBase64.decode(bcryptHash.split(bcryptSalt)[1])\n\n      return safeEqual(hash, phcNode.hash)\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Find if the hash value needs a rehash or not. The rehash is\n   * required when.\n   *\n   * 1. The bcrypt version is changed\n   * 2. Number of rounds are changed\n   * 3. Bcrypt hash is not using MCF hash format\n   * 4. The provided hash has not been hashed with bcrypt\n   *\n   * ```ts\n   * const isValid = await bcrypt.verify(hash, plainText)\n   *\n   * // Plain password is valid and hash needs a rehash\n   * if (isValid && await bcrypt.needsReHash(hash)) {\n   *   const newHash = await bcrypt.make(plainText)\n   * }\n   * ```\n   */\n  needsReHash(value: string): boolean {\n    if (value.startsWith('$2b') || value.startsWith('$2a')) {\n      return true\n    }\n\n    const phcNode = this.#phcFormatter.deserialize(value)\n    if (phcNode.id !== 'bcrypt') {\n      return true\n    }\n\n    /**\n     * If config version is separate from hash version, then a\n     * re-hash is needed\n     */\n    if (phcNode.version !== this.#config.version) {\n      return true\n    }\n\n    /**\n     * Make sure all the encoded params are same as the config.\n     * Otherwise a re-hash is needed\n     */\n    if (!phcNode.params) {\n      return true\n    }\n    if (phcNode.params.r !== this.#config.rounds) {\n      return true\n    }\n\n    return false\n  }\n}\n"],"mappings":"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","names":["encode","decode"]}