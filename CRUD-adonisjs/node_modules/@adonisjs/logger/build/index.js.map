{"version":3,"sources":["../src/targets/file.ts","../src/targets/create.ts","../src/targets/pretty.ts","../src/targets/main.ts","../src/define_config.ts","../src/debug.ts","../src/logger_manager.ts"],"sourcesContent":["/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { FileTargetOptions, TransportTargetOptions, Level } from '../types.js'\n\n/**\n * Construct options object for the file target.\n */\nexport function file(options?: FileTargetOptions, level?: string | Level): TransportTargetOptions {\n  return {\n    target: 'pino/file',\n    level: level,\n    options: options || {},\n  }\n}\n","/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { TransportTargetOptions } from '../types.js'\n\n/**\n * Exposes the API to construct targets array conditionally.\n */\nexport class Targets {\n  #collection: TransportTargetOptions[] = []\n\n  /**\n   * Add target to the list of targets\n   */\n  push(value: TransportTargetOptions): this {\n    this.#collection.push(value)\n    return this\n  }\n\n  /**\n   * Conditionally add target to the list targets. The target will only be added\n   *  if the `conditional` is true.\n   *\n   * ```ts\n   * targets.if(process.env.NODE_ENV === 'development', {\n   *   target: 'pino-pretty'\n   * })\n   * ```\n   */\n  pushIf(conditional: boolean, value: TransportTargetOptions | (() => TransportTargetOptions)) {\n    if (conditional) {\n      this.#collection.push(typeof value === 'function' ? value() : value)\n    }\n\n    return this\n  }\n\n  /**\n   * Conditionally add target to the list targets. The target will only be added\n   * unless the `conditional` is true.\n   *\n   * ```ts\n   * targets.unless(process.env.NODE_ENV === 'production', {\n   *   target: 'pino-pretty'\n   * })\n   * ```\n   */\n  pushUnless(conditional: boolean, value: TransportTargetOptions | (() => TransportTargetOptions)) {\n    if (!conditional) {\n      this.#collection.push(typeof value === 'function' ? value() : value)\n    }\n\n    return this\n  }\n\n  /**\n   * Get targets array\n   */\n  toArray(): TransportTargetOptions[] {\n    return this.#collection\n  }\n}\n","/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { TransportTargetOptions, Level, PrettyTargetOptions } from '../types.js'\n\n/**\n * Construct options object for the pino-pretty target.\n */\nexport function pretty(\n  options?: PrettyTargetOptions,\n  level?: string | Level\n): TransportTargetOptions {\n  return {\n    target: 'pino-pretty',\n    level: level,\n    options: options || {},\n  }\n}\n","/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { file } from './file.js'\nimport { Targets } from './create.js'\nimport { pretty } from './pretty.js'\n\n/**\n * Create the targets array conditionally.\n */\nexport function targets(): Targets {\n  return new Targets()\n}\n\ntargets.file = file\ntargets.pretty = pretty\n","/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { RuntimeException } from '@poppinss/utils'\n\nimport type { LoggerConfig, LoggerManagerConfig } from './types.js'\nimport debug from './debug.js'\n\n/**\n * Define the logger config. The config object must have a default property\n * pointing to the key within the loggers object.\n */\nexport function defineConfig<KnownLoggers extends Record<string, LoggerConfig>>(\n  config: LoggerManagerConfig<KnownLoggers>\n): LoggerManagerConfig<KnownLoggers> {\n  if (!config.loggers) {\n    throw new RuntimeException('Missing \"loggers\" property in logger config file')\n  }\n\n  if (!config.default) {\n    throw new RuntimeException(\n      'Missing \"default\" property in logger config. Specify a default logger'\n    )\n  }\n\n  if (!config.loggers[config.default]) {\n    throw new RuntimeException(\n      `Missing \"loggers.${String(config.default)}\". It is referenced by the \"default\" logger`\n    )\n  }\n\n  Object.keys(config.loggers).forEach((loggerName) => {\n    const logger = config.loggers[loggerName]\n    if (logger.transport && 'targets' in logger.transport) {\n      logger.transport.targets.forEach((target) => {\n        if (!target.level) {\n          debug('inherting \"%s\" target level from \"%s\" logger', target.target, loggerName)\n          target.level = logger.level\n        }\n      })\n    }\n  })\n\n  return config\n}\n","/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { debuglog } from 'node:util'\nexport default debuglog('adonisjs:logger')\n","/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Logger as PinoLogger } from 'pino'\n\nimport debug from './debug.js'\nimport { Logger } from './logger.js'\nimport { LoggerConfig, LoggerManagerConfig } from './types.js'\n\n/**\n * Logger manager is used to manage multiple instances of the Logger. The\n * loggers are created using the default config and the logger instances\n * are cached forever.\n */\nexport class LoggerManager<\n  KnownLoggers extends Record<string, LoggerConfig>,\n> extends Logger<LoggerConfig> {\n  /**\n   * Registered config\n   */\n  #config: LoggerManagerConfig<KnownLoggers>\n\n  /**\n   * Created loggers. Logger instances are cached forever\n   */\n  #loggers: Map<keyof KnownLoggers, Logger<KnownLoggers[keyof KnownLoggers]>> = new Map()\n\n  constructor(config: LoggerManagerConfig<KnownLoggers>) {\n    super(config.loggers[config.default])\n    this.#config = config\n    debug('creating logger manager. config: %O', this.#config)\n  }\n\n  /**\n   * Creates an instance of the logger\n   */\n  protected createLogger<K extends keyof KnownLoggers>(logger: K, config: KnownLoggers[K]) {\n    if (!config.name && typeof logger === 'string') {\n      config.name = logger\n    }\n\n    return new Logger(config)\n  }\n\n  /**\n   * Get instance of a logger\n   */\n  use<K extends keyof KnownLoggers>(logger: K): Logger<KnownLoggers[K]>\n  use(): Logger<LoggerConfig>\n  use<K extends keyof KnownLoggers>(logger?: K): Logger<KnownLoggers[K]> | Logger<LoggerConfig> {\n    let loggerToUse = logger || this.#config.default\n\n    if (this.#loggers.has(loggerToUse)) {\n      debug('using logger from cache. name: \"%s\"', logger)\n      return this.#loggers.get(loggerToUse)! as Logger<KnownLoggers[K]> | Logger<LoggerConfig>\n    }\n\n    const config = this.#config.loggers[loggerToUse]\n    debug('creating logger. name: \"%s\", config: %O', loggerToUse, config)\n\n    const loggerInstance = this.createLogger(loggerToUse, config)\n    this.#loggers.set(loggerToUse, loggerInstance)\n\n    return loggerInstance as Logger<KnownLoggers[K]> | Logger<LoggerConfig>\n  }\n\n  /**\n   * Create a logger instance from the config. The created instance\n   * is not managed by the manager\n   */\n  create<Config extends LoggerConfig>(\n    config: Config,\n    pino?: PinoLogger<keyof Config['customLevels'] & string>\n  ) {\n    return new Logger(config, pino)\n  }\n}\n"],"mappings":"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","names":[]}