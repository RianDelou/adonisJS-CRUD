{"version":3,"sources":["../src/pino.ts","../src/logger.ts"],"sourcesContent":["/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport {\n  pino,\n  version,\n  transport,\n  multistream,\n  destination,\n  LoggerOptions,\n  stdSerializers,\n  stdTimeFunctions,\n  type Logger as PinoLogger,\n} from 'pino'\nimport type { LoggerConfig, TimestampKeywords, LevelMapping } from './types.js'\n\n/**\n * Mapping pino timestamp formatters to keywords\n */\nconst TimestampFormatters: { [Keyword in TimestampKeywords]: () => string } = {\n  iso: stdTimeFunctions.isoTime,\n  epoch: stdTimeFunctions.epochTime,\n  unix: stdTimeFunctions.unixTime,\n}\n\n/**\n * Returns an instance of pino logger by adjusting the config options\n */\nexport function createPino<Config extends LoggerConfig>(\n  options: Config\n): PinoLogger<keyof Config['customLevels'] & string> {\n  const { desination, timestamp, ...rest } = options\n  const pinoOptions: LoggerOptions<any> = Object.assign({}, rest)\n\n  /**\n   * Use pino formatters when a keyword is used\n   */\n  if (typeof timestamp === 'string' && TimestampFormatters[timestamp]) {\n    pinoOptions.timestamp = TimestampFormatters[timestamp]\n  }\n\n  return desination ? pino(pinoOptions, desination) : pino(pinoOptions)\n}\n\n/**\n * Static copy of pino level mappings\n */\nexport const levels: LevelMapping = {\n  labels: {\n    10: 'trace',\n    20: 'debug',\n    30: 'info',\n    40: 'warn',\n    50: 'error',\n    60: 'fatal',\n  },\n  values: {\n    fatal: 60,\n    error: 50,\n    warn: 40,\n    info: 30,\n    debug: 20,\n    trace: 10,\n  },\n}\n\nexport { destination, transport, stdSerializers, multistream, stdTimeFunctions, version }\n","/*\n * @adonisjs/logger\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n// @ts-expect-error \"Package does not have types\"\nimport abstractLogging from 'abstract-logging'\nimport type { LevelWithSilent, Logger as PinoLogger } from 'pino'\n\nimport { createPino, levels, version } from './pino.js'\nimport type { LoggerConfig, LevelMapping, Bindings, ChildLoggerOptions } from './types.js'\n\n/**\n * A thin wrapper on top of Pino with support for disabling the logger.\n *\n * The config is same as the options accepted by pino with following additions\n *\n * - enabled: A flag to turn off the logger. You can still use the logger API, but\n *            nothing will be logged.\n * - destination: A stream to pass to pino as the desintation stream. With pino, you\n *                pass is at the 2nd argument, with Logger, you pass it as an option.\n *\n * ```ts\n * const logger = new Logger({ enabled: true })\n * logger.info('hello world')\n * ```\n *\n * ```ts\n * const logger = new Logger({ enabled: true, desintation: pino.destination(2) })\n * logger.error('something went wrong')\n * ```\n */\nexport class Logger<Config extends LoggerConfig = LoggerConfig> {\n  pino: PinoLogger<keyof Config['customLevels'] & string>\n\n  constructor(\n    protected config: Config,\n    pino?: PinoLogger<keyof Config['customLevels'] & string>\n  ) {\n    if (!this.config.enabled) {\n      this.pino = abstractLogging\n    } else {\n      this.pino = pino || createPino(this.config)\n    }\n  }\n\n  /**\n   * Check if the logger is enabled\n   */\n  get isEnabled() {\n    return this.config.enabled\n  }\n\n  /**\n   * A map of levels\n   */\n  get levels(): LevelMapping {\n    if (!this.isEnabled) {\n      return levels\n    }\n\n    return this.pino.levels\n  }\n\n  /**\n   * Returns the current logger level\n   */\n  get level(): string {\n    if (!this.isEnabled) {\n      return this.config.level || 'info'\n    }\n\n    return this.pino.level\n  }\n\n  /**\n   * Update logger level\n   */\n  set level(level: string) {\n    if (!this.isEnabled) {\n      this.config.level = level\n      return\n    }\n\n    this.pino.level = level\n  }\n\n  /**\n   * Returns the current logger level number\n   */\n  get levelNumber(): number {\n    if (!this.isEnabled) {\n      return levels.values[this.config.level || 'info']\n    }\n\n    return this.pino.levelVal\n  }\n\n  /**\n   * Returns the pino version\n   */\n  get pinoVersion(): string {\n    return version\n  }\n\n  /**\n   * Returns the pino version\n   */\n  get version(): string {\n    return version\n  }\n\n  /**\n   * Returns a boolean telling if level is enabled or\n   * not.\n   */\n  isLevelEnabled(level: string): boolean {\n    if (!this.isEnabled) {\n      return false\n    }\n\n    return this.pino.isLevelEnabled(level)\n  }\n\n  /**\n   * Run the callback when the level is enabled. Helpful for\n   * conditionally logging, especially when the processing\n   * of computing log data is expensive.\n   *\n   * ```ts\n   * logger.ifLevelEnabled('trace', () => {\n   *   const data = inspect(someValue)\n   *   logger.info(data)\n   * })\n   * ```\n   */\n  ifLevelEnabled(level: string, callback: (logger: this) => Promise<void>): Promise<void>\n  ifLevelEnabled(level: string, callback: (logger: this) => void): void\n  ifLevelEnabled(level: string, callback: (logger: this) => void): void | Promise<void> {\n    if (this.isLevelEnabled(level)) {\n      return callback(this)\n    }\n  }\n\n  /**\n   * Log message for any named level\n   */\n  log(\n    level: LevelWithSilent | keyof Config['customLevels'],\n    message: string,\n    ...values: any[]\n  ): void\n  log(\n    level: LevelWithSilent | keyof Config['customLevels'],\n    mergingObject: any,\n    message: string,\n    ...values: any[]\n  ): void\n  log(\n    level: LevelWithSilent | keyof Config['customLevels'],\n    mergingObject: any,\n    message: string,\n    ...values: any[]\n  ): void {\n    /**\n     * Abstract logger does not have \"silent\" method\n     */\n    if (!this.isEnabled) {\n      return\n    }\n\n    ;(this.pino[level] as any)(mergingObject, message, ...values)\n  }\n\n  /**\n   * Log message at trace level\n   */\n  trace<T extends object>(obj: T, message?: string, ...values: any[]): void\n  trace(obj: unknown, message?: string, ...values: any[]): void\n  trace(message: string, ...values: any[]): void\n  trace(mergingObject: any, message: string, ...values: any[]): void {\n    this.log('trace', mergingObject, message, ...values)\n  }\n\n  /**\n   * Log message at debug level\n   */\n  debug<T extends object>(obj: T, message?: string, ...values: any[]): void\n  debug(obj: unknown, message?: string, ...values: any[]): void\n  debug(message: string, ...values: any[]): void\n  debug(mergingObject: any, message: string, ...values: any[]): void {\n    this.log('debug', mergingObject, message, ...values)\n  }\n\n  /**\n   * Log message at info level\n   */\n  info<T extends object>(obj: T, message?: string, ...values: any[]): void\n  info(obj: unknown, message?: string, ...values: any[]): void\n  info(message: string, ...values: any[]): void\n  info(mergingObject: any, message: string, ...values: any[]): void {\n    this.log('info', mergingObject, message, ...values)\n  }\n\n  /**\n   * Log message at warn level\n   */\n  warn<T extends object>(obj: T, message?: string, ...values: any[]): void\n  warn(obj: unknown, message?: string, ...values: any[]): void\n  warn(message: string, ...values: any[]): void\n  warn(mergingObject: any, message: string, ...values: any[]): void {\n    this.log('warn', mergingObject, message, ...values)\n  }\n\n  /**\n   * Log message at error level\n   */\n  error<T extends object>(obj: T, message?: string, ...values: any[]): void\n  error(obj: unknown, message?: string, ...values: any[]): void\n  error(message: string, ...values: any[]): void\n  error(mergingObject: any, message: string, ...values: any[]): void {\n    this.log('error', mergingObject, message, ...values)\n  }\n\n  /**\n   * Log message at fatal level\n   */\n  fatal<T extends object>(obj: T, message?: string, ...values: any[]): void\n  fatal(obj: unknown, message?: string, ...values: any[]): void\n  fatal(message: string, ...values: any[]): void\n  fatal(mergingObject: any, message: string, ...values: any[]): void {\n    this.log('fatal', mergingObject, message, ...values)\n  }\n\n  /**\n   * Log message at silent level\n   */\n  silent<T extends object>(obj: T, message?: string, ...values: any[]): void\n  silent(obj: unknown, message?: string, ...values: any[]): void\n  silent(message: string, ...values: any[]): void\n  silent(mergingObject: any, message: string, ...values: any[]): void {\n    this.log('silent', mergingObject, message, ...values)\n  }\n\n  /**\n   * Returns a child logger instance\n   */\n  child<ChildOptions extends ChildLoggerOptions>(\n    bindings: Bindings,\n    options?: ChildOptions\n  ): Logger<Config> {\n    if (!this.isEnabled) {\n      return this\n    }\n\n    return new Logger(this.config, this.pino.child(bindings, options))\n  }\n\n  /**\n   * Returns default bindings for the logger\n   */\n  bindings(): Bindings {\n    if (!this.isEnabled) {\n      return {}\n    }\n\n    return this.pino.bindings()\n  }\n}\n"],"mappings":";AASA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,OAEK;AAMP,IAAM,sBAAwE;AAAA,EAC5E,KAAK,iBAAiB;AAAA,EACtB,OAAO,iBAAiB;AAAA,EACxB,MAAM,iBAAiB;AACzB;AAKO,SAAS,WACd,SACmD;AACnD,QAAM,EAAE,YAAY,WAAW,GAAG,KAAK,IAAI;AAC3C,QAAM,cAAkC,OAAO,OAAO,CAAC,GAAG,IAAI;AAK9D,MAAI,OAAO,cAAc,YAAY,oBAAoB,SAAS,GAAG;AACnE,gBAAY,YAAY,oBAAoB,SAAS;AAAA,EACvD;AAEA,SAAO,aAAa,KAAK,aAAa,UAAU,IAAI,KAAK,WAAW;AACtE;AAKO,IAAM,SAAuB;AAAA,EAClC,QAAQ;AAAA,IACN,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,EACN;AAAA,EACA,QAAQ;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,EACT;AACF;;;AC5DA,OAAO,qBAAqB;AA0BrB,IAAM,SAAN,MAAM,QAAmD;AAAA,EAG9D,YACY,QACVA,OACA;AAFU;AAGV,QAAI,CAAC,KAAK,OAAO,SAAS;AACxB,WAAK,OAAO;AAAA,IACd,OAAO;AACL,WAAK,OAAOA,SAAQ,WAAW,KAAK,MAAM;AAAA,IAC5C;AAAA,EACF;AAAA,EAXA;AAAA;AAAA;AAAA;AAAA,EAgBA,IAAI,YAAY;AACd,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAAuB;AACzB,QAAI,CAAC,KAAK,WAAW;AACnB,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAAgB;AAClB,QAAI,CAAC,KAAK,WAAW;AACnB,aAAO,KAAK,OAAO,SAAS;AAAA,IAC9B;AAEA,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,MAAM,OAAe;AACvB,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,OAAO,QAAQ;AACpB;AAAA,IACF;AAEA,SAAK,KAAK,QAAQ;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAAsB;AACxB,QAAI,CAAC,KAAK,WAAW;AACnB,aAAO,OAAO,OAAO,KAAK,OAAO,SAAS,MAAM;AAAA,IAClD;AAEA,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAAsB;AACxB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAkB;AACpB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,OAAwB;AACrC,QAAI,CAAC,KAAK,WAAW;AACnB,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,KAAK,eAAe,KAAK;AAAA,EACvC;AAAA,EAgBA,eAAe,OAAe,UAAwD;AACpF,QAAI,KAAK,eAAe,KAAK,GAAG;AAC9B,aAAO,SAAS,IAAI;AAAA,IACtB;AAAA,EACF;AAAA,EAgBA,IACE,OACA,eACA,YACG,QACG;AAIN,QAAI,CAAC,KAAK,WAAW;AACnB;AAAA,IACF;AAEA;AAAC,IAAC,KAAK,KAAK,KAAK,EAAU,eAAe,SAAS,GAAG,MAAM;AAAA,EAC9D;AAAA,EAQA,MAAM,eAAoB,YAAoB,QAAqB;AACjE,SAAK,IAAI,SAAS,eAAe,SAAS,GAAG,MAAM;AAAA,EACrD;AAAA,EAQA,MAAM,eAAoB,YAAoB,QAAqB;AACjE,SAAK,IAAI,SAAS,eAAe,SAAS,GAAG,MAAM;AAAA,EACrD;AAAA,EAQA,KAAK,eAAoB,YAAoB,QAAqB;AAChE,SAAK,IAAI,QAAQ,eAAe,SAAS,GAAG,MAAM;AAAA,EACpD;AAAA,EAQA,KAAK,eAAoB,YAAoB,QAAqB;AAChE,SAAK,IAAI,QAAQ,eAAe,SAAS,GAAG,MAAM;AAAA,EACpD;AAAA,EAQA,MAAM,eAAoB,YAAoB,QAAqB;AACjE,SAAK,IAAI,SAAS,eAAe,SAAS,GAAG,MAAM;AAAA,EACrD;AAAA,EAQA,MAAM,eAAoB,YAAoB,QAAqB;AACjE,SAAK,IAAI,SAAS,eAAe,SAAS,GAAG,MAAM;AAAA,EACrD;AAAA,EAQA,OAAO,eAAoB,YAAoB,QAAqB;AAClE,SAAK,IAAI,UAAU,eAAe,SAAS,GAAG,MAAM;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,MACE,UACA,SACgB;AAChB,QAAI,CAAC,KAAK,WAAW;AACnB,aAAO;AAAA,IACT;AAEA,WAAO,IAAI,QAAO,KAAK,QAAQ,KAAK,KAAK,MAAM,UAAU,OAAO,CAAC;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKA,WAAqB;AACnB,QAAI,CAAC,KAAK,WAAW;AACnB,aAAO,CAAC;AAAA,IACV;AAEA,WAAO,KAAK,KAAK,SAAS;AAAA,EAC5B;AACF;","names":["pino"]}