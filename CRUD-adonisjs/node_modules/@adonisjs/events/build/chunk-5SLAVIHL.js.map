{"version":3,"sources":["../src/emitter.ts","../src/debug.ts","../src/events_buffer.ts"],"sourcesContent":["/*\n * @adonisjs/events\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport is from '@sindresorhus/is'\nimport type { Application } from '@adonisjs/application'\nimport Emittery, { type UnsubscribeFunction } from 'emittery'\nimport { moduleCaller, moduleImporter } from '@adonisjs/fold'\n\nimport debug from './debug.js'\nimport { EventsBuffer } from './events_buffer.js'\nimport type {\n  Listener,\n  LazyImport,\n  EmitterLike,\n  Constructor,\n  ListenerMethod,\n  AllowedEventTypes,\n  ListenerClassWithHandleMethod,\n} from './types.js'\n\n/**\n * Event emitter is built on top of emittery with support class based\n * events and listeners\n */\nexport class Emitter<EventsList extends Record<string | symbol | number, any>>\n  implements EmitterLike<EventsList>\n{\n  /**\n   * Event classes to symbols mapping. We need symbols as emittery\n   * does not support class based event names\n   */\n  #eventsClassSymbols: Map<Constructor<any>, symbol> = new Map()\n\n  /**\n   * A collection of events and their listeners. We do not track listeners\n   * listening for events only once\n   */\n  #eventsListeners: Map<\n    AllowedEventTypes,\n    Map<Listener<any, Constructor<any>>, ListenerMethod<any>>\n  > = new Map()\n\n  /**\n   * Underlying transport to emit events\n   */\n  #transport = new Emittery()\n\n  /**\n   * Events buffer. The events are collected inside an in-memory\n   * buffer during fakes\n   */\n  #eventsBuffer?: EventsBuffer<EventsList>\n\n  /**\n   * A set of events to fake\n   */\n  #eventsToFake: Set<AllowedEventTypes | '*'> = new Set()\n\n  /**\n   * Error handler to catch all errors thrown by listeners\n   */\n  #errorHandler?: (event: keyof EventsList | Constructor<any>, error: any, data: any) => void\n\n  /**\n   * Reference to AdonisJS application, we need the application root\n   * and container reference from it.\n   */\n  #app: Application<any>\n\n  /**\n   * Returns a map of events and their registered listeners. The\n   * map key is the event name and the value is another map\n   * of listeners.\n   *\n   * The listeners map key is the original binding listener\n   * and the value is a callback function.\n   */\n  get eventsListeners() {\n    return this.#eventsListeners\n  }\n\n  constructor(app: Application<any>) {\n    this.#app = app\n  }\n\n  /**\n   * Returns the symbol for a class based event.\n   */\n  #getEventClassSymbol(event: Constructor<any>): symbol {\n    if (!this.#eventsClassSymbols.has(event)) {\n      this.#eventsClassSymbols.set(event, Symbol(event.name))\n    }\n\n    return this.#eventsClassSymbols.get(event)!\n  }\n\n  /**\n   * Normalizes the event to emittery supported data types. The class\n   * constructors are cached against a unique symbol.\n   */\n  #resolveEvent(event: AllowedEventTypes): string | symbol | number {\n    if (is.class(event)) {\n      return this.#getEventClassSymbol(event)\n    }\n\n    return event\n  }\n\n  /**\n   * Returns the event listeners map\n   */\n  #getEventListeners(event: AllowedEventTypes) {\n    if (!this.#eventsListeners.has(event)) {\n      this.#eventsListeners.set(event, new Map())\n    }\n\n    return this.#eventsListeners.get(event)!\n  }\n\n  /**\n   * Normalizes the event listener to a function that can be passed to\n   * emittery.\n   */\n  #normalizeEventListener(listener: Listener<any, Constructor>): ListenerMethod<any> {\n    /**\n     * Parse string based listener\n     */\n    if (typeof listener === 'string') {\n      const parts = listener.split('.')\n      const method = parts.length === 1 ? 'handle' : parts.pop()!\n      const moduleRefId = parts.join('.')\n      return moduleImporter(() => this.#app.import(moduleRefId), method).toCallable(\n        this.#app.container\n      )\n    }\n\n    /**\n     * Parse array based listener with the listener reference\n     * or lazily imported listener class\n     */\n    if (Array.isArray(listener)) {\n      const listenerModule = listener[0]\n      const method = listener[1] || 'handle'\n\n      /**\n       * Class reference\n       */\n      if (is.class(listenerModule)) {\n        return moduleCaller(listenerModule, method).toCallable(this.#app.container)\n      }\n\n      /**\n       * Lazily loaded module\n       */\n      return moduleImporter(listenerModule, method).toCallable(this.#app.container)\n    }\n\n    return listener\n  }\n\n  /**\n   * Resolves the event listener either from the cache or normalizes\n   * it and stores it inside the cache\n   */\n  #resolveEventListener(\n    event: AllowedEventTypes,\n    listener: Listener<any, Constructor>\n  ): ListenerMethod<any> {\n    const eventListeners = this.#getEventListeners(event)\n    if (!eventListeners.has(listener)) {\n      eventListeners.set(listener, this.#normalizeEventListener(listener))\n    }\n\n    return eventListeners.get(listener)!\n  }\n\n  /**\n   * Register a global error handler\n   */\n  onError(\n    callback: (event: keyof EventsList | Constructor<any>, error: any, data: any) => void\n  ): this {\n    this.#errorHandler = callback\n    return this\n  }\n\n  /**\n   * Bind multiple listeners to listen for a single event. The listen\n   * method is a convenience helper to be used with class based\n   * events and listeners.\n   */\n  listen<Event extends Constructor<any>>(\n    event: Event,\n    listeners: (\n      | ListenerClassWithHandleMethod<InstanceType<Event>>\n      | LazyImport<ListenerClassWithHandleMethod<InstanceType<Event>>>\n    )[]\n  ) {\n    listeners.forEach((listener) => this.on(event, [listener, 'handle']))\n  }\n\n  /**\n   * Listen for an event. The method returns the unsubscribe function.\n   */\n  on<Event extends Constructor, ListenerClass extends Constructor>(\n    event: Event,\n    listener: Listener<InstanceType<Event>, ListenerClass>\n  ): UnsubscribeFunction\n  on<Name extends keyof EventsList, ListenerClass extends Constructor>(\n    event: Name,\n    listener: Listener<EventsList[Name], ListenerClass>\n  ): UnsubscribeFunction\n  on<Event extends AllowedEventTypes>(\n    event: Event,\n    listener: Listener<any, Constructor>\n  ): UnsubscribeFunction {\n    if (debug.enabled) {\n      debug('registering event listener, event: %O, listener: %O', event, listener)\n    }\n\n    const normalizedEvent = this.#resolveEvent(event)\n    const normalizedListener = this.#resolveEventListener(event, listener)\n\n    this.#transport.on(normalizedEvent, normalizedListener)\n    return () => this.off(event, listener)\n  }\n\n  /**\n   * Listen for an event only once\n   */\n  once<Event extends Constructor, ListenerClass extends Constructor>(\n    event: Event,\n    listener: Listener<InstanceType<Event>, ListenerClass>\n  ): void\n  once<Name extends keyof EventsList, ListenerClass extends Constructor>(\n    event: Name,\n    listener: Listener<EventsList[Name], ListenerClass>\n  ): void\n  once<Event extends AllowedEventTypes>(event: Event, listener: Listener<any, Constructor>): void {\n    if (debug.enabled) {\n      debug('registering one time event listener, event: %O, listener: %O', event, listener)\n    }\n\n    const normalizedEvent = this.#resolveEvent(event)\n    const normalizedListener = this.#normalizeEventListener(listener)\n\n    /**\n     * Listening for an event and unsubscribing right after the event is emitted.\n     * Internally emittery does the same thing, but they do not await the\n     * handler. Therefore, the \"once\" listeners will finish after the\n     * \"emit\" call. This behavior is not inline with the \"on\" event\n     * listeners.\n     */\n    const off = this.#transport.on(normalizedEvent, async (data) => {\n      off()\n      debug('removing one time event listener, event: %O', event)\n      await normalizedListener(data)\n    })\n  }\n\n  /**\n   * Attach a listener to listen for all the events. Wildcard listeners\n   * can only be defined as inline callbacks.\n   */\n  onAny(\n    listener: (event: AllowedEventTypes, data: any) => any | Promise<any>\n  ): UnsubscribeFunction {\n    return this.#transport.onAny(listener)\n  }\n\n  /**\n   * Emit event. The event listeners will be called asynchronously\n   * in parallel.\n   *\n   * You can await this method to wait for events listeners to finish\n   */\n  async emit<Event extends Constructor<any>>(event: Event, data: InstanceType<Event>): Promise<void>\n  async emit<Name extends keyof EventsList>(event: Name, data: EventsList[Name]): Promise<void>\n  async emit<Event extends AllowedEventTypes>(event: Event, data: any): Promise<void> {\n    /**\n     * Entertain fakes if exists\n     */\n    if (this.#eventsToFake.has(event) || this.#eventsToFake.has('*')) {\n      debug('faking emit. event: %O, data: %O', event, data)\n      this.#eventsBuffer!.add(event, data)\n      return\n    }\n\n    try {\n      const normalizedEvent = this.#resolveEvent(event)\n      await this.#transport.emit(normalizedEvent, data)\n    } catch (error) {\n      if (this.#errorHandler) {\n        this.#errorHandler(event, error, data)\n      } else {\n        throw error\n      }\n    }\n  }\n\n  /**\n   * Emit events serially. The event listeners will be called asynchronously\n   * in the same sequence as they are registered.\n   *\n   * You can await this method to wait for events listeners to finish\n   */\n  async emitSerial<Event extends Constructor<any>>(\n    event: Event,\n    data: InstanceType<Event>\n  ): Promise<void>\n  async emitSerial<Name extends keyof EventsList>(\n    event: Name,\n    data: EventsList[Name]\n  ): Promise<void>\n  async emitSerial<Event extends AllowedEventTypes>(event: Event, data: any): Promise<void> {\n    /**\n     * Entertain fakes if exists\n     */\n    if (this.#eventsToFake.has(event) || this.#eventsToFake.has('*')) {\n      debug('faking emit. event: %O, data: %O', event, data)\n      this.#eventsBuffer!.add(event, data)\n      return\n    }\n\n    try {\n      const normalizedEvent = this.#resolveEvent(event)\n      await this.#transport.emitSerial(normalizedEvent, data)\n    } catch (error) {\n      if (this.#errorHandler) {\n        this.#errorHandler(event, error, data)\n      } else {\n        throw error\n      }\n    }\n  }\n\n  /**\n   * Remove a specific listener for an event\n   */\n  off(event: keyof EventsList | Constructor<any>, listener: Listener<any, Constructor<any>>): void {\n    if (debug.enabled) {\n      debug('removing listener, event: %O, listener: %O', event, listener)\n    }\n\n    const normalizedEvent = this.#resolveEvent(event)\n    const listeners = this.#getEventListeners(event)\n    const normalizedListener = listeners.get(listener)\n\n    if (!normalizedListener) {\n      return\n    }\n\n    listeners.delete(listener)\n    this.#transport.off(normalizedEvent, normalizedListener)\n  }\n\n  /**\n   * Remove a specific listener listening for all the events\n   */\n  offAny(\n    listener: (event: keyof EventsList | Constructor<any>, data: any) => any | Promise<any>\n  ): this {\n    this.#transport.offAny(listener)\n    return this\n  }\n\n  /**\n   * Remove a specific listener for an event\n   *\n   * @alias \"off\"\n   */\n  clearListener(\n    event: keyof EventsList | Constructor<any>,\n    listener: Listener<any, Constructor<any>>\n  ): void {\n    return this.off(event, listener)\n  }\n\n  /**\n   * Clear all listeners for a specific event\n   */\n  clearListeners(event: keyof EventsList | Constructor<any>) {\n    debug('clearing all listeners for event %O', event)\n    this.#transport.clearListeners(this.#resolveEvent(event))\n    this.#eventsListeners.delete(event)\n  }\n\n  /**\n   * Clear all listeners for all the events\n   */\n  clearAllListeners() {\n    debug('clearing all event listeners')\n    this.#transport.clearListeners()\n    this.#eventsListeners.clear()\n  }\n\n  /**\n   * Get count of listeners for a given event or all the events\n   */\n  listenerCount(event?: keyof EventsList | Constructor<any>): number {\n    return this.#transport.listenerCount(event ? this.#resolveEvent(event) : undefined)\n  }\n\n  /**\n   * Find if an event has one or more listeners\n   */\n  hasListeners(event?: keyof EventsList | Constructor<any>): boolean {\n    return this.listenerCount(event) > 0\n  }\n\n  /**\n   * Fake one or more events. The listeners for faked events will\n   * not be invoked.\n   *\n   * The return value is an events buffer that collects all the\n   * events within memory.\n   *\n   * Calling this method one than once drops the existing fakes and\n   * creates new one.\n   */\n  fake(events?: (keyof EventsList | Constructor<any>)[]): EventsBuffer<EventsList> {\n    this.restore()\n    this.#eventsBuffer = new EventsBuffer<EventsList>()\n\n    if (!events) {\n      debug('faking all events')\n      this.#eventsToFake.add('*')\n    } else {\n      debug('faking events: %O', events)\n      events.forEach((event) => this.#eventsToFake.add(event))\n    }\n\n    return this.#eventsBuffer\n  }\n\n  /**\n   * Restore fakes\n   */\n  restore() {\n    debug('restoring existing fakes')\n    this.#eventsToFake.clear()\n    this.#eventsBuffer?.flush()\n    this.#eventsBuffer = undefined\n  }\n}\n","/*\n * @adonisjs/events\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { debuglog } from 'node:util'\nexport default debuglog('adonisjs:events')\n","/*\n * @adonisjs/events\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport is from '@sindresorhus/is'\nimport string from '@poppinss/utils/string'\nimport { AssertionError } from 'node:assert'\n\nimport type { AllowedEventTypes, BufferedEvent, BufferedEventsList, Constructor } from './types.js'\n\n/**\n * Callback function to narrow down an event from\n * the events buffer list\n */\ntype EventFinderCallback<\n  EventsList extends Record<string | symbol | number, any>,\n  Event extends keyof EventsList | Constructor,\n> = (\n  event: Event extends keyof EventsList\n    ? BufferedEvent<Event, EventsList[Event]>\n    : Event extends Constructor<infer A>\n      ? BufferedEvent<Event, A>\n      : never\n) => boolean\n\n/**\n * Exposes API to filter, find events from the events buffer.\n */\nexport class EventsBuffer<EventsList extends Record<string | symbol | number, any>> {\n  /**\n   * Buffered events\n   */\n  #events: BufferedEventsList<EventsList>[] = []\n\n  /**\n   * Track emitted event\n   */\n  add<Name extends AllowedEventTypes>(event: Name, data: any): void {\n    this.#events.push({ event: event as any, data })\n  }\n\n  /**\n   * Get all the emitted events\n   */\n  all() {\n    return this.#events\n  }\n\n  /**\n   * Returns the size of captured events\n   */\n  size() {\n    return this.#events.length\n  }\n\n  /**\n   * Find if an event was emitted\n   */\n  exists<Event extends keyof EventsList | Constructor>(\n    event: Event,\n    finder?: EventFinderCallback<EventsList, Event>\n  ): boolean {\n    return !!this.find(event, finder)\n  }\n\n  /**\n   * Find a specific event\n   */\n  find<Event extends keyof EventsList | Constructor>(\n    event: Event,\n    finder?: EventFinderCallback<EventsList, Event>\n  ):\n    | (Event extends keyof EventsList\n        ? BufferedEvent<Event, EventsList[Event]>\n        : Event extends Constructor<infer A>\n          ? BufferedEvent<Event, A>\n          : never)\n    | null {\n    return (this.#events.find((bufferedEvent) => {\n      if (!finder) {\n        return bufferedEvent.event === event\n      }\n\n      return (\n        bufferedEvent.event === event &&\n        finder(bufferedEvent as Parameters<EventFinderCallback<EventsList, Event>>[0])\n      )\n    }) || null) as any\n  }\n\n  /**\n   * Assert a given event has been emitted\n   */\n  assertEmitted<Event extends keyof EventsList | Constructor>(\n    event: Event,\n    finder?: EventFinderCallback<EventsList, Event>\n  ): void {\n    const hasEvent = this.exists(event, finder)\n\n    if (!hasEvent) {\n      const message = is.class(event)\n        ? `Expected \"[class ${event.name}]\" event to be emitted`\n        : `Expected \"${String(event)}\" event to be emitted`\n\n      throw new AssertionError({\n        message: message,\n        expected: true,\n        actual: false,\n        operator: 'strictEqual',\n        stackStartFn: this.assertEmitted,\n      })\n    }\n  }\n\n  /**\n   * Assert number of times an event has been emitted\n   */\n  assertEmittedCount<Event extends keyof EventsList | Constructor>(\n    event: Event,\n    count: number\n  ): void {\n    const actual = this.all().filter((bufferedEvent) => bufferedEvent.event === event).length\n\n    if (actual !== count) {\n      const eventName = is.class(event) ? `[class ${event.name}]` : String(event)\n      throw new AssertionError({\n        message: `Expected \"${eventName}\" event to be emitted \"${count}\" ${string.pluralize(\n          'time',\n          count\n        )}, instead it was emitted \"${actual}\" ${string.pluralize('time', actual)}`,\n        actual,\n        expected: count,\n      })\n    }\n  }\n\n  /**\n   * Assert a given event has been not been emitted\n   */\n  assertNotEmitted<Event extends keyof EventsList | Constructor<any>>(\n    event: Event,\n    finder?: EventFinderCallback<EventsList, Event>\n  ): void {\n    const hasEvent = this.exists(event, finder)\n\n    if (hasEvent) {\n      const isClass = is.class(event)\n      const message = isClass\n        ? `Unexpected \"[class ${event.name}]\" event was emitted`\n        : `Unexpected \"${String(event)}\" event was emitted`\n\n      throw new AssertionError({\n        message: message,\n        expected: false,\n        actual: true,\n        operator: 'strictEqual',\n        stackStartFn: this.assertNotEmitted,\n      })\n    }\n  }\n\n  /**\n   * Assert a given event has been not been emitted\n   */\n  assertNoneEmitted(): void {\n    const eventsSize = this.size()\n    if (eventsSize > 0) {\n      throw new AssertionError(\n        Object.assign(\n          {\n            message: `Expected zero events to be emitted. Instead received \"${eventsSize}\" ${string.pluralize(\n              'event',\n              eventsSize\n            )}`,\n            expected: 0,\n            actual: eventsSize,\n            operator: 'strictEqual',\n            stackStartFn: this.assertNoneEmitted,\n          },\n          {\n            showDiff: true,\n          }\n        )\n      )\n    }\n  }\n\n  /**\n   * Flush events collected within memory\n   */\n  flush() {\n    this.#events = []\n  }\n}\n"],"mappings":"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","names":["is","is"]}