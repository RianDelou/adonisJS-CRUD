{"version":3,"sources":["../src/env.ts","../src/errors.ts","../src/validator.ts","../src/parser.ts","../src/processor.ts"],"sourcesContent":["/*\n * @adonisjs/env\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { schema as envSchema, type ValidateFn } from '@poppinss/validator-lite'\nimport { EnvValidator } from './validator.js'\nimport { EnvProcessor } from './processor.js'\nimport { EnvParser } from './parser.js'\n\n/**\n * A wrapper over \"process.env\" with types information.\n *\n * ```ts\n * const validate = Env.rules({\n *   PORT: Env.schema.number()\n * })\n *\n * const validatedEnvVars = validate(process.env)\n *\n * const env = new EnvValues(validatedEnvVars)\n * env.get('PORT') // type === number\n * ```\n */\nexport class Env<EnvValues extends Record<string, any>> {\n  /**\n   * A cache of env values\n   */\n  #values: EnvValues\n\n  constructor(values: EnvValues) {\n    this.#values = values\n  }\n\n  /**\n   * Create an instance of the env class by validating the\n   * environment variables. Also, the `.env` files are\n   * loaded from the appRoot\n   */\n  static async create<Schema extends { [key: string]: ValidateFn<unknown> }>(\n    appRoot: URL,\n    schema: Schema\n  ): Promise<\n    Env<{\n      [K in keyof Schema]: ReturnType<Schema[K]>\n    }>\n  > {\n    const values = await new EnvProcessor(appRoot).process()\n    const validator = this.rules(schema)\n    return new Env(validator.validate(values))\n  }\n\n  /**\n   * Define an identifier for any environment value. The callback is invoked\n   * when the value match the identifier to modify its interpolation.\n   */\n  static identifier(name: string, callback: (value: string) => Promise<string> | string): void {\n    EnvParser.identifier(name, callback)\n  }\n\n  /**\n   * Remove an identifier\n   */\n  static removeIdentifier(name: string): void {\n    EnvParser.removeIdentifier(name)\n  }\n\n  /**\n   * The schema builder for defining validation rules\n   */\n  static schema = envSchema\n\n  /**\n   * Define the validation rules for validating environment\n   * variables. The return value is an instance of the\n   * env validator\n   */\n  static rules<T extends { [key: string]: ValidateFn<unknown> }>(schema: T): EnvValidator<T> {\n    const validator = new EnvValidator<T>(schema)\n    return validator\n  }\n\n  /**\n   * Get the value of an environment variable by key. The values are\n   * lookedup inside the validated environment and \"process.env\"\n   * is used as a fallback.\n   *\n   * The second param is the default value, which is returned when\n   * the environment variable does not exist.\n   *\n   * ```ts\n   * Env.get('PORT')\n   *\n   * // With default value\n   * Env.get('PORT', 3000)\n   * ```\n   */\n  get<K extends keyof EnvValues>(key: K): EnvValues[K]\n  get<K extends keyof EnvValues>(\n    key: K,\n    defaultValue: Exclude<EnvValues[K], undefined>\n  ): Exclude<EnvValues[K], undefined>\n  get(key: string): string | undefined\n  get(key: string, defaultValue: string): string\n  get(key: string, defaultValue?: any): any {\n    /**\n     * Return cached value\n     */\n    if (this.#values[key] !== undefined) {\n      return this.#values[key]\n    }\n\n    /**\n     * Get value from \"process.env\" and update the cache\n     */\n    const envValue = process.env[key]\n    if (envValue) {\n      return envValue\n    }\n\n    /**\n     * Return default value when unable to lookup any other value\n     */\n    return defaultValue\n  }\n\n  /**\n   * Update/set value of an environment variable.\n   *\n   * The value is not casted/validated using the validator, so make sure\n   * to set the correct data type.\n   *\n   * ```ts\n   * Env.set('PORT', 3000)\n   *\n   * Env.get('PORT') === 3000 // true\n   * process.env.PORT === '3000' // true\n   * ```\n   */\n  set<K extends keyof EnvValues>(key: K, value: EnvValues[K]): void\n  set(key: string, value: string): void\n  set(key: string | keyof EnvValues, value: any): void {\n    this.#values[key] = value\n    process.env[key as string] = value\n  }\n}\n","/*\n * @adonisjs/env\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { createError, Exception } from '@poppinss/utils'\n\n/**\n * Exception raised when one or more env variables\n * are invalid\n */\nexport const E_INVALID_ENV_VARIABLES = class EnvValidationException extends Exception {\n  static message = 'Validation failed for one or more environment variables'\n  static code = 'E_INVALID_ENV_VARIABLES'\n  help: string = ''\n}\n\nexport const E_IDENTIFIER_ALREADY_DEFINED = createError<[string]>(\n  'The identifier \"%s\" is already defined',\n  'E_IDENTIFIER_ALREADY_DEFINED',\n  500\n)\n","/*\n * @adonisjs/env\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Exception } from '@poppinss/utils'\nimport { ValidateFn } from '@poppinss/validator-lite'\n\nimport { E_INVALID_ENV_VARIABLES } from './errors.js'\n\n/**\n * Exposes the API to validate environment variables against a\n * pre-defined schema.\n *\n * The class is not exported in the main API and used internally.\n */\nexport class EnvValidator<Schema extends { [key: string]: ValidateFn<unknown> }> {\n  #schema: Schema\n  #error: Exception\n\n  constructor(schema: Schema) {\n    this.#schema = schema\n    this.#error = new E_INVALID_ENV_VARIABLES()\n  }\n\n  /**\n   * Accepts an object of values to validate against the pre-defined\n   * schema.\n   *\n   * The return value is a merged copy of the original object and the\n   * values mutated by the schema validator.\n   */\n  validate(values: { [K: string]: string | undefined }): {\n    [K in keyof Schema]: ReturnType<Schema[K]>\n  } {\n    const help: string[] = []\n\n    const validated = Object.keys(this.#schema).reduce(\n      (result, key) => {\n        const value = process.env[key] || values[key]\n\n        try {\n          result[key] = this.#schema[key](key, value) as any\n        } catch (error) {\n          help.push(`- ${error.message}`)\n        }\n        return result\n      },\n      { ...values }\n    ) as { [K in keyof Schema]: ReturnType<Schema[K]> }\n\n    if (help.length) {\n      this.#error.help = help.join('\\n')\n      throw this.#error\n    }\n\n    return validated\n  }\n}\n","/*\n * @adonisjs/env\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport dotenv, { DotenvParseOutput } from 'dotenv'\nimport { E_IDENTIFIER_ALREADY_DEFINED } from './errors.js'\n\n/**\n * Env parser parses the environment variables from a string formatted\n * as a key-value pair seperated using an `=`. For example:\n *\n * ```dotenv\n * PORT=3333\n * HOST=127.0.0.1\n * ```\n *\n * The variables can reference other environment variables as well using `$`.\n * For example:\n *\n * ```dotenv\n * PORT=3333\n * REDIS_PORT=$PORT\n * ```\n *\n * The variables using characters other than letters can wrap variable\n * named inside a curly brace.\n *\n * ```dotenv\n * APP-PORT=3333\n * REDIS_PORT=${APP-PORT}\n * ```\n *\n * You can escape the `$` sign with a backtick.\n *\n * ```dotenv\n * REDIS_PASSWORD=foo\\$123\n * ```\n *\n * ## Usage\n *\n * ```ts\n * const parser = new EnvParser(envContents)\n * const output = parser.parse()\n *\n * // The output is a key-value pair\n * ```\n */\nexport class EnvParser {\n  #envContents: string\n  #preferProcessEnv: boolean = true\n  static #identifiers: Record<string, (value: string) => Promise<string> | string> = {}\n\n  constructor(envContents: string, options?: { ignoreProcessEnv: boolean }) {\n    if (options?.ignoreProcessEnv) {\n      this.#preferProcessEnv = false\n    }\n\n    this.#envContents = envContents\n  }\n\n  /**\n   * Define an identifier for any environment value. The callback is invoked\n   * when the value match the identifier to modify its interpolation.\n   */\n  static identifier(name: string, callback: (value: string) => Promise<string> | string): void {\n    if (this.#identifiers[name]) {\n      throw new E_IDENTIFIER_ALREADY_DEFINED([name])\n    }\n\n    this.#identifiers[name] = callback\n  }\n\n  /**\n   * Remove an identifier\n   */\n  static removeIdentifier(name: string): void {\n    delete this.#identifiers[name]\n  }\n\n  /**\n   * Returns the value from the parsed object\n   */\n  #getValue(key: string, parsed: DotenvParseOutput): string {\n    if (this.#preferProcessEnv && process.env[key]) {\n      return process.env[key]!\n    }\n\n    if (parsed[key]) {\n      return this.#interpolate(parsed[key], parsed)\n    }\n\n    return process.env[key] || ''\n  }\n\n  /**\n   * Interpolating the token wrapped inside the mustache braces.\n   */\n  #interpolateMustache(token: string, parsed: DotenvParseOutput) {\n    /**\n     * Finding the closing brace. If closing brace is missing, we\n     * consider the block as a normal string\n     */\n    const closingBrace = token.indexOf('}')\n    if (closingBrace === -1) {\n      return token\n    }\n\n    /**\n     * Then we pull everything until the closing brace, except\n     * the opening brace and trim off all white spaces.\n     */\n    const varReference = token.slice(1, closingBrace).trim()\n\n    /**\n     * Getting the value of the reference inside the braces\n     */\n    return `${this.#getValue(varReference, parsed)}${token.slice(closingBrace + 1)}`\n  }\n\n  /**\n   * Interpolating the variable reference starting with a\n   * `$`. We only capture numbers,letter and underscore.\n   * For other characters, one can use the mustache\n   * braces.\n   */\n  #interpolateVariable(token: string, parsed: any) {\n    return token.replace(/[a-zA-Z0-9_]+/, (key) => {\n      return this.#getValue(key, parsed)\n    })\n  }\n\n  /**\n   * Interpolates the referenced values\n   */\n  #interpolate(value: string, parsed: DotenvParseOutput): string {\n    const tokens = value.split('$')\n\n    let newValue = ''\n    let skipNextToken = true\n\n    tokens.forEach((token) => {\n      /**\n       * If the value is an escaped sequence, then we replace it\n       * with a `$` and then skip the next token.\n       */\n      if (token === '\\\\') {\n        newValue += '$'\n        skipNextToken = true\n        return\n      }\n\n      /**\n       * Use the value as it is when \"skipNextToken\" is set to true.\n       */\n      if (skipNextToken) {\n        /**\n         * Replace the ending escape sequence with a $\n         */\n        newValue += token.replace(/\\\\$/, '$')\n        /**\n         *  and then skip the next token if it ends with escape sequence\n         */\n        if (token.endsWith('\\\\')) {\n          return\n        }\n      } else {\n        /**\n         * Handle mustache block\n         */\n        if (token.startsWith('{')) {\n          newValue += this.#interpolateMustache(token, parsed)\n          return\n        }\n\n        /**\n         * Process all words as variable\n         */\n        newValue += this.#interpolateVariable(token, parsed)\n      }\n\n      /**\n       * Process next token\n       */\n      skipNextToken = false\n    })\n\n    return newValue\n  }\n\n  /**\n   * Parse the env string to an object of environment variables.\n   */\n  async parse(): Promise<DotenvParseOutput> {\n    const envCollection = dotenv.parse(this.#envContents.trim())\n    const identifiers = Object.keys(EnvParser.#identifiers)\n    let result: DotenvParseOutput = {}\n\n    $keyLoop: for (const key in envCollection) {\n      const value = this.#getValue(key, envCollection)\n\n      if (value.includes(':')) {\n        for (const identifier of identifiers) {\n          if (value.startsWith(`${identifier}:`)) {\n            result[key] = await EnvParser.#identifiers[identifier](\n              value.substring(identifier.length + 1)\n            )\n\n            continue $keyLoop\n          }\n\n          if (value.startsWith(`${identifier}\\\\:`)) {\n            result[key] = identifier + value.substring(identifier.length + 1)\n\n            continue $keyLoop\n          }\n        }\n\n        result[key] = value\n      } else {\n        result[key] = value\n      }\n    }\n\n    return result\n  }\n}\n","/*\n * @adonisjs/application\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport debug from './debug.js'\nimport { EnvParser } from './parser.js'\nimport { EnvLoader } from './loader.js'\n\n/**\n * Env processors loads, parses and process environment variables.\n */\nexport class EnvProcessor {\n  /**\n   * App root is needed to load files\n   */\n  #appRoot: URL\n\n  constructor(appRoot: URL) {\n    this.#appRoot = appRoot\n  }\n\n  /**\n   * Parse env variables from raw contents\n   */\n  async #processContents(envContents: string, store: Record<string, any>) {\n    /**\n     * Collected env variables\n     */\n    if (!envContents.trim()) {\n      return store\n    }\n\n    const parser = new EnvParser(envContents)\n    const values = await parser.parse()\n\n    Object.keys(values).forEach((key) => {\n      let value = process.env[key]\n\n      if (!value) {\n        value = values[key]\n        process.env[key] = values[key]\n      }\n\n      if (!store[key]) {\n        store[key] = value\n      }\n    })\n\n    return store\n  }\n\n  /**\n   * Parse env variables by loading dot files.\n   */\n  async #loadAndProcessDotFiles() {\n    const loader = new EnvLoader(this.#appRoot)\n    const envFiles = await loader.load()\n\n    if (debug.enabled) {\n      debug(\n        'processing .env files (priority from top to bottom) %O',\n        envFiles.map((file) => file.path)\n      )\n    }\n\n    /**\n     * Collected env variables\n     */\n    const envValues: Record<string, any> = {}\n    await Promise.all(envFiles.map(({ contents }) => this.#processContents(contents, envValues)))\n    return envValues\n  }\n\n  /**\n   * Process env variables\n   */\n  async process() {\n    return this.#loadAndProcessDotFiles()\n  }\n}\n"],"mappings":"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","names":[]}