{"version":3,"sources":["../src/errors.ts","../src/encryption.ts","../src/hmac.ts","../src/message_verifier.ts"],"sourcesContent":["/*\n * @adonisjs/encryption\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { createError } from '@poppinss/utils'\n\nexport const E_INSECURE_APP_KEY = createError(\n  'The value of \"app.appKey\" should be atleast 16 characters long',\n  'E_INSECURE_APP_KEY'\n)\n\nexport const E_MISSING_APP_KEY = createError(\n  'Missing \"app.appKey\". The key is required to encrypt values',\n  'E_MISSING_APP_KEY'\n)\n","/*\n * @adonisjs/encryption\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport string from '@poppinss/utils/string'\nimport { base64, MessageBuilder } from '@poppinss/utils'\nimport { createHash, createCipheriv, createDecipheriv } from 'node:crypto'\n\nimport { Hmac } from './hmac.js'\nimport * as errors from './errors.js'\nimport type { EncryptionOptions } from './types.js'\nimport { MessageVerifier } from './message_verifier.js'\n\n/**\n * The encryption class allows encrypting and decrypting values using `aes-256-cbc` or `aes-128-cbc`\n * algorithms. The encrypted value uses a unique iv for every encryption and this ensures semantic\n * security (read more https://en.wikipedia.org/wiki/Semantic_security).\n */\nexport class Encryption {\n  #options: Required<EncryptionOptions>\n\n  /**\n   * The key for signing and encrypting values. It is derived\n   * from the user provided secret.\n   */\n  #cryptoKey: Buffer\n\n  /**\n   * Use `dot` as a separator for joining encrypted value, iv and the\n   * hmac hash. The idea is borrowed from JWTs.\n   */\n  #separator = '.'\n\n  /**\n   * Reference to the instance of message verifier for signing\n   * and verifying values.\n   */\n  verifier: MessageVerifier\n\n  /**\n   * Reference to base64 object for base64 encoding/decoding values\n   */\n  base64: typeof base64 = base64\n\n  /**\n   * The algorithm in use\n   */\n  get algorithm(): 'aes-256-cbc' {\n    return this.#options.algorithm\n  }\n\n  constructor(options: EncryptionOptions) {\n    const secretValue =\n      options.secret && typeof options.secret === 'object' && 'release' in options.secret\n        ? options.secret.release()\n        : options.secret\n\n    this.#options = { algorithm: 'aes-256-cbc', ...options }\n    this.#validateSecret(secretValue)\n    this.#cryptoKey = createHash('sha256').update(secretValue).digest()\n    this.verifier = new MessageVerifier(secretValue)\n  }\n\n  /**\n   * Validates the app secret\n   */\n  #validateSecret(secret?: string) {\n    if (typeof secret !== 'string') {\n      throw new errors.E_MISSING_APP_KEY()\n    }\n\n    if (secret.length < 16) {\n      throw new errors.E_INSECURE_APP_KEY()\n    }\n  }\n\n  /**\n   * Encrypt a given piece of value using the app secret. A wide range of\n   * data types are supported.\n   *\n   * - String\n   * - Arrays\n   * - Objects\n   * - Booleans\n   * - Numbers\n   * - Dates\n   *\n   * You can optionally define a purpose for which the value was encrypted and\n   * mentioning a different purpose/no purpose during decrypt will fail.\n   */\n  encrypt(payload: any, expiresIn?: string | number, purpose?: string) {\n    /**\n     * Using a random string as the iv for generating unpredictable values\n     */\n    const iv = string.random(16)\n\n    /**\n     * Creating chiper\n     */\n    const cipher = createCipheriv(this.algorithm, this.#cryptoKey, iv)\n\n    /**\n     * Encoding value to a string so that we can set it on the cipher\n     */\n    const encodedValue = new MessageBuilder().build(payload, expiresIn, purpose)\n\n    /**\n     * Set final to the cipher instance and encrypt it\n     */\n    const encrypted = Buffer.concat([cipher.update(encodedValue, 'utf-8'), cipher.final()])\n\n    /**\n     * Concatenate `encrypted value` and `iv` by urlEncoding them. The concatenation is required\n     * to generate the HMAC, so that HMAC checks for integrity of both the `encrypted value`\n     * and the `iv`.\n     */\n    const result = `${this.base64.urlEncode(encrypted)}${this.#separator}${this.base64.urlEncode(\n      iv\n    )}`\n\n    /**\n     * Returns the result + hmac\n     */\n    return `${result}${this.#separator}${new Hmac(this.#cryptoKey).generate(result)}`\n  }\n\n  /**\n   * Decrypt value and verify it against a purpose\n   */\n  decrypt<T extends any>(value: unknown, purpose?: string): T | null {\n    if (typeof value !== 'string') {\n      return null\n    }\n\n    /**\n     * Make sure the encrypted value is in correct format. ie\n     * [encrypted value].[iv].[hash]\n     */\n    const [encryptedEncoded, ivEncoded, hash] = value.split(this.#separator)\n    if (!encryptedEncoded || !ivEncoded || !hash) {\n      return null\n    }\n\n    /**\n     * Make sure we are able to urlDecode the encrypted value\n     */\n    const encrypted = this.base64.urlDecode(encryptedEncoded, 'base64')\n    if (!encrypted) {\n      return null\n    }\n\n    /**\n     * Make sure we are able to urlDecode the iv\n     */\n    const iv = this.base64.urlDecode(ivEncoded)\n    if (!iv) {\n      return null\n    }\n\n    /**\n     * Make sure the hash is correct, it means the first 2 parts of the\n     * string are not tampered.\n     */\n    const isValidHmac = new Hmac(this.#cryptoKey).compare(\n      `${encryptedEncoded}${this.#separator}${ivEncoded}`,\n      hash\n    )\n\n    if (!isValidHmac) {\n      return null\n    }\n\n    /**\n     * The Decipher can raise exceptions with malformed input, so we wrap it\n     * to avoid leaking sensitive information\n     */\n    try {\n      const decipher = createDecipheriv(this.algorithm, this.#cryptoKey, iv)\n      const decrypted = decipher.update(encrypted, 'base64', 'utf8') + decipher.final('utf8')\n      return new MessageBuilder().verify(decrypted, purpose)\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * Create a children instance with different secret key\n   */\n  child(options?: EncryptionOptions) {\n    return new Encryption({ ...this.#options, ...options })\n  }\n}\n","/*\n * @adonisjs/encryption\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { createHmac } from 'node:crypto'\nimport { base64, safeEqual } from '@poppinss/utils'\n\n/**\n * A generic class for generating SHA-256 Hmac for verifying the value\n * integrity.\n */\nexport class Hmac {\n  #key: Buffer\n\n  constructor(key: Buffer) {\n    this.#key = key\n  }\n\n  /**\n   * Generate the hmac\n   */\n  generate(value: string) {\n    return base64.urlEncode(createHmac('sha256', this.#key).update(value).digest())\n  }\n\n  /**\n   * Compare raw value against an existing hmac\n   */\n  compare(value: string, existingHmac: string) {\n    return safeEqual(this.generate(value), existingHmac)\n  }\n}\n","/*\n * @adonisjs/encryption\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { createHash } from 'node:crypto'\nimport { base64, MessageBuilder, RuntimeException } from '@poppinss/utils'\nimport { Hmac } from './hmac.js'\n\n/**\n * Message verifier is similar to the encryption. However, the actual payload\n * is not encrypted and just base64 encoded. This is helpful when you are\n * not concerned about the confidentiality of the data, but just want to\n * make sure that is not tampered after encoding.\n */\nexport class MessageVerifier {\n  /**\n   * The key for signing and encrypting values. It is derived\n   * from the user provided secret.\n   */\n  #cryptoKey: Buffer\n\n  /**\n   * Use `dot` as a separator for joining encrypted value, iv and the\n   * hmac hash. The idea is borrowed from JWT's in which each part\n   * of the payload is concatenated with a dot.\n   */\n  #separator = '.'\n\n  constructor(secret: string) {\n    this.#cryptoKey = createHash('sha256').update(secret).digest()\n  }\n\n  /**\n   * Sign a given piece of value using the app secret. A wide range of\n   * data types are supported.\n   *\n   * - String\n   * - Arrays\n   * - Objects\n   * - Booleans\n   * - Numbers\n   * - Dates\n   *\n   * You can optionally define a purpose for which the value was signed and\n   * mentioning a different purpose/no purpose during unsign will fail.\n   */\n  sign(payload: any, expiresIn?: string | number, purpose?: string) {\n    if (payload === null || payload === undefined) {\n      throw new RuntimeException(`Cannot sign \"${payload}\" value`)\n    }\n\n    const encoded = base64.urlEncode(new MessageBuilder().build(payload, expiresIn, purpose))\n    return `${encoded}${this.#separator}${new Hmac(this.#cryptoKey).generate(encoded)}`\n  }\n\n  /**\n   * Unsign a previously signed value with an optional purpose\n   */\n  unsign<T extends any>(payload: string, purpose?: string): T | null {\n    if (typeof payload !== 'string') {\n      return null\n    }\n\n    /**\n     * Ensure value is in correct format\n     */\n    const [encoded, hash] = payload.split(this.#separator)\n    if (!encoded || !hash) {\n      return null\n    }\n\n    /**\n     * Ensure value can be decoded\n     */\n    const decoded = base64.urlDecode(encoded, undefined, false)\n    if (!decoded) {\n      return null\n    }\n\n    const isValid = new Hmac(this.#cryptoKey).compare(encoded, hash)\n    return isValid ? new MessageBuilder().verify(decoded, purpose) : null\n  }\n}\n"],"mappings":"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","names":["base64","MessageBuilder","createHash","base64","base64","base64","createHash","MessageBuilder"]}