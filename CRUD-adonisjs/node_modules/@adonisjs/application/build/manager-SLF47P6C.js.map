{"version":3,"sources":["../src/stubs/manager.ts","../src/stubs/stub.ts","../src/helpers.ts"],"sourcesContent":["/*\n * @adonisjs/application\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { join } from 'node:path'\nimport { cp } from 'node:fs/promises'\nimport { RuntimeException, fsReadAll } from '@poppinss/utils'\n\nimport debug from '../debug.js'\nimport { Stub } from './stub.js'\nimport { Application } from '../application.js'\nimport { readFileFromSources } from '../helpers.js'\n\n/**\n * Stub Manager is used to read and copy stubs from different sources. Also\n * allows creating resources from pre-existing stubs\n */\nexport class StubsManager {\n  #app: Application<any>\n\n  /**\n   * Absolute path to the directory where stubs should\n   * be published or read from with priority\n   */\n  #publishTarget: string\n\n  constructor(app: Application<any>, publishTarget: string) {\n    this.#app = app\n    this.#publishTarget = publishTarget\n  }\n\n  /**\n   * Returns the path to the stubs source directory of a package\n   */\n  async #getPackageSource(packageName: string) {\n    const pkgMainExports = await this.#app.import(packageName)\n    if (!pkgMainExports.stubsRoot) {\n      throw new RuntimeException(\n        `Cannot resolve stubs from package \"${packageName}\". Make sure the package entrypoint exports \"stubsRoot\" variable`\n      )\n    }\n\n    return pkgMainExports.stubsRoot\n  }\n\n  /**\n   * Creates an instance of stub by its name. The lookup is performed inside\n   * the publishTarget and the optional source or pkg destination.\n   */\n  async build(stubName: string, options?: { source?: string; pkg?: string }) {\n    const sources: string[] = [this.#publishTarget]\n\n    /**\n     * Push custom source (if defined)\n     */\n    if (options?.source) {\n      sources.push(options.source)\n    }\n\n    /**\n     * Push pkg source (if defined)\n     */\n    if (options?.pkg) {\n      sources.push(await this.#getPackageSource(options.pkg))\n    }\n\n    debug('finding stub \"%s\" in sources \"%O\"', stubName, sources)\n\n    /**\n     * Attempt to read file from one of the available sources\n     */\n    const file = await readFileFromSources(stubName, sources)\n    if (!file) {\n      throw new RuntimeException(`Unable to find stub \"${stubName}\"`, {\n        cause: `Scanned locations: \\n${sources.join('\\n')}`,\n      })\n    }\n\n    debug('building stub \"%s\"', file.filePath)\n    return new Stub(this.#app, file.contents, file.filePath)\n  }\n\n  /**\n   * Copy one or more stub files from a custom location to publish\n   * target.\n   */\n  async copy(\n    stubPath: string,\n    options: { overwrite?: boolean } & ({ source: string } | { pkg: string })\n  ) {\n    const filesCopied: string[] = []\n    const copyOptions = {\n      recursive: true,\n      force: options.overwrite === true ? true : false,\n    }\n\n    /**\n     * Getting the source absolute path\n     */\n    const source =\n      'source' in options\n        ? join(options.source, stubPath)\n        : join(await this.#getPackageSource(options.pkg), stubPath)\n\n    try {\n      const files = await fsReadAll(source, {\n        filter: (path) => path === '' || path.endsWith('.stub'),\n      })\n\n      debug('copying stubs from \"%s\" with options %O', source, copyOptions)\n      debug('preparing to copy stubs \"%s\"', files)\n\n      /**\n       * Copy all files one by one and maintain the files structure\n       */\n      for (let filePath of files) {\n        const sourcePath = join(source, filePath)\n        const destinationPath = join(this.#publishTarget, stubPath, filePath)\n        await cp(sourcePath, destinationPath, copyOptions)\n        filesCopied.push(destinationPath)\n      }\n\n      return filesCopied\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        const readingSource = 'source' in options ? options.source : options.pkg\n        throw new Error(`Cannot find \"${stubPath}\" stub in \"${readingSource}\" destination`)\n      }\n      throw error\n    }\n  }\n}\n","/*\n * @adonisjs/application\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n// @ts-expect-error\nimport * as tempura from 'tempura'\nimport string from '@poppinss/utils/string'\nimport { dirname, isAbsolute } from 'node:path'\nimport { RuntimeException } from '@poppinss/utils'\nimport { mkdir, writeFile } from 'node:fs/promises'\nimport stringHelpers from '@poppinss/utils/string'\nimport StringBuilder from '@poppinss/utils/string_builder'\n\nimport debug from '../debug.js'\nimport type { Application } from '../application.js'\nimport { parseStubExports, pathExists } from '../helpers.js'\n\n/**\n * String builder function + object shared with the stubs\n */\nfunction stubStringBuilder(value: string | StringBuilder) {\n  return new StringBuilder(value)\n}\nObject.assign(stubStringBuilder, stringHelpers)\n\n/**\n * The stub class uses tempura template engine to process\n * a stub template and generate a resource file.\n *\n * Finding the correct stub to use is outside of the scope\n * of this class.\n */\nexport class Stub {\n  /**\n   * The absolute path to the stub file. Need it for reporting\n   * errors\n   */\n  #stubPath: string\n\n  /**\n   * The contents of the stub to process\n   */\n  #stubContents: string\n\n  /**\n   * Application class reference\n   */\n  #app: Application<any>\n\n  constructor(app: Application<any>, stubContents: string, stubPath: string) {\n    this.#app = app\n    this.#stubPath = stubPath\n    this.#stubContents = stubContents\n  }\n\n  /**\n   * Patch error stack and point it to the stub file\n   */\n  #patchErrorStack(error: Error) {\n    const stack = error.stack!.split('\\n')\n    stack.splice(1, 0, `    at anonymous (${this.#stubPath}:0:0)`)\n    error.stack = stack.join('\\n')\n  }\n\n  /**\n   * Patch tempura error stack and point it to the stub file\n   */\n  #patchTempuraStack(error: Error) {\n    const stack = error.stack!.split('\\n')\n\n    /**\n     * Check if there is an error in the template processing, then\n     * pick the exact line number from the reported error\n     */\n    const templateErrorLine = stack[1].match(/<anonymous>:(\\d+):\\d+\\)$/)\n    if (!templateErrorLine) {\n      stack.splice(1, 0, `    at anonymous (${this.#stubPath}:0:0)`)\n    } else {\n      stack.splice(1, 0, `    at anonymous (${this.#stubPath}:${templateErrorLine[1]}:0)`)\n    }\n\n    error.stack = stack.join('\\n')\n  }\n\n  /**\n   * Validates the \"to\" attribute\n   */\n  #validateToAttribute(attributes: Record<string, any>) {\n    if (!attributes.to) {\n      const error = new RuntimeException(`Missing \"to\" attribute in stub exports`)\n      throw error\n    }\n\n    if (!isAbsolute(attributes.to)) {\n      const error = new RuntimeException(\n        `The value for \"to\" attribute must be an absolute file path`\n      )\n      throw error\n    }\n  }\n\n  /**\n   * Returns the default state for the stub\n   */\n  #getStubDefaults() {\n    return {\n      app: this.#app,\n      randomString: string.random,\n      generators: this.#app.generators,\n      exports: (value: any) => {\n        return `<!--EXPORT_START-->${JSON.stringify(value)}<!--EXPORT_END-->`\n      },\n      string: stubStringBuilder,\n    }\n  }\n\n  /**\n   * Renders stub using tempura templating syntax.\n   */\n  async #renderStub(data: Record<string, any>) {\n    try {\n      const render = tempura.compile(this.#stubContents, {\n        props: Object.keys(data),\n      })\n      return render(data).trim()\n    } catch (error) {\n      this.#patchTempuraStack(error)\n      throw error\n    }\n  }\n\n  /**\n   * Parsers the stub exports\n   */\n  #parseExports(stubOutput: string) {\n    try {\n      const { body, attributes } = parseStubExports(stubOutput)\n      this.#validateToAttribute(attributes)\n      return { attributes, body }\n    } catch (error) {\n      this.#patchErrorStack(error)\n      throw error\n    }\n  }\n\n  /**\n   * Prepare stub to be written to the disk\n   */\n  async prepare(stubData: Record<string, any>) {\n    const data = {\n      ...this.#getStubDefaults(),\n      ...stubData,\n    }\n\n    const { attributes, body } = this.#parseExports(await this.#renderStub(data))\n    debug('prepared stub %s', body)\n    debug('stub attributes %O', attributes)\n\n    return {\n      contents: body,\n      destination: attributes.to,\n      force: stubData.force !== undefined ? stubData.force : !!attributes.force,\n      attributes,\n    }\n  }\n\n  /**\n   * Generate resource for the stub. Writes file to the disk\n   */\n  async generate(stubData: Record<string, any>) {\n    const { force, ...stub } = await this.prepare(stubData)\n    const hasFile = await pathExists(stub.destination)\n    const directory = dirname(stub.destination)\n\n    if (!hasFile) {\n      debug('writing file to %s', stub.destination)\n      await mkdir(directory, { recursive: true })\n      await writeFile(stub.destination, stub.contents)\n      return {\n        status: 'created' as const,\n        skipReason: null,\n        ...stub,\n      }\n    }\n\n    /**\n     * Overwrite file because force flag is enabled\n     */\n    if (hasFile && force) {\n      debug('overwriting file to %s', stub.destination)\n      await mkdir(directory, { recursive: true })\n      await writeFile(stub.destination, stub.contents)\n      return {\n        status: 'force_created' as const,\n        skipReason: null,\n        ...stub,\n      }\n    }\n\n    return {\n      status: 'skipped' as const,\n      skipReason: 'File already exists',\n      ...stub,\n    }\n  }\n}\n","/*\n * @adonisjs/application\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { join } from 'node:path'\nimport type { PathLike } from 'node:fs'\nimport { access, readFile } from 'node:fs/promises'\n\n/**\n * Attempts to read a file from multiple sources and returns the contents\n * of the first matching one. `null` is returned when file does not\n * exist in any of the sources.\n */\nexport async function readFileFromSources(fileName: string, sources: string[]) {\n  for (let source of sources) {\n    const filePath = join(source, fileName)\n    const contents = await readFileOptional(filePath)\n    if (contents !== null) {\n      return {\n        contents,\n        filePath,\n        fileName,\n        source,\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Optionally read the contents of a file\n */\nexport async function readFileOptional(filePath: URL | string): Promise<string | null> {\n  try {\n    return await readFile(filePath, 'utf-8')\n  } catch (error) {\n    /* c8 ignore next 3 */\n    if (error.code !== 'ENOENT') {\n      throw error\n    }\n\n    return null\n  }\n}\n\n/**\n * Check if a file for the given path exists\n */\nexport async function pathExists(path: PathLike): Promise<boolean> {\n  try {\n    await access(path)\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Parsers exports from a stub\n */\nexport function parseStubExports(contents: string) {\n  const chunks = contents.split(/\\r\\n|\\n/)\n  const body: string[] = []\n  const exportedBlocks: string[] = []\n\n  chunks.forEach((line) => {\n    if (line.includes('<!--EXPORT_START-->')) {\n      let [inital, rest] = line.split('<!--EXPORT_START-->')\n      let [exports, remaining] = rest.split('<!--EXPORT_END-->')\n      inital = inital.trim()\n      remaining = remaining.trim()\n\n      const remainingContents =\n        inital && remaining ? `${inital}\\n${remaining}` : inital || remaining || ''\n\n      exportedBlocks.push(exports)\n      if (remainingContents) {\n        body.push(remainingContents)\n      }\n    } else {\n      body.push(line)\n    }\n  })\n\n  const attributes = exportedBlocks.reduce(\n    (result, block) => {\n      Object.assign(result, JSON.parse(block))\n      return result\n    },\n    {} as Record<string, any>\n  )\n\n  return { attributes, body: body.join('\\n') }\n}\n"],"mappings":"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","names":["join","RuntimeException","RuntimeException","join"]}